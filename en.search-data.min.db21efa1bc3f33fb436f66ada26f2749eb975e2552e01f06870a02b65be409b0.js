'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/study-javascript/docs/basic/practice/',title:"实践",section:"第一部分 基础入门",content:"实践 #  "}),a.add({id:1,href:'/study-javascript/docs/appendix/turorial/',title:"教程",section:"第四部分 附录",content:"教程 #  基础 #  ruanyf/jstraining #  全栈工程师培训材料，帮助学习者掌握 JavaScript 全栈开发的基本知识，承担简单 Web 应用的前后端开发。\n一共四讲，适合两天的训练营。\ndenysdovhan/wtfjs #  A list of funny and tricky JavaScript examples\nnefe/You-Dont-Need-jQuery #  使用原生方法实现 jQuery API 功能（暂时只支持 IE10 以上浏览器）。\nverekia/js-stack-from-scratch #  🛠️⚡ Step-by-step tutorial to build a modern JavaScript stack.\nlowerfish/js-stack-from-scratch #  从零开始构建 JavaScript 技术栈 第 2 版\n 进阶 #   "}),a.add({id:2,href:'/study-javascript/docs/basic/practice/spec/baidu/',title:"百度",section:"编程规范",content:"百度 JavaScript 编码规范 #  1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 换行\n2.2.4 语句\n2.3 命名\n2.4 注释\n2.4.1 单行注释\n2.4.2 多行注释\n2.4.3 文档化注释\n2.4.4 类型定义\n2.4.5 文件注释\n2.4.6 命名空间注释\n2.4.7 类注释\n2.4.8 函数/方法注释\n2.4.9 事件注释\n2.4.10 常量注释\n2.4.11 复杂类型注释\n2.4.12 AMD 模块注释\n2.4.13 细节注释\n3 语言特性\n3.1 变量\n3.2 条件\n3.3 循环\n3.4 类型\n3.4.1 类型检测\n3.4.2 类型转换\n3.5 字符串\n3.6 对象\n3.7 数组\n3.8 函数\n3.8.1 函数长度\n3.8.2 参数设计\n3.8.3 闭包\n3.8.4 空函数\n3.9 面向对象\n3.10 动态特性\n3.10.1 eval\n3.10.2 动态执行代码\n3.10.3 with\n3.10.4 delete\n3.10.5 对象属性\n4 浏览器环境\n4.1 模块化\n4.1.1 AMD\n4.1.2 define\n4.1.3 require\n4.2 DOM\n4.2.1 元素获取\n4.2.2 样式获取\n4.2.3 样式设置\n4.2.4 DOM 操作\n4.2.5 DOM 事件\n1 前言 #  JavaScript 在百度一直有着广泛的应用，特别是在浏览器端的行为管理。本文档的目标是使 JavaScript 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 JavaScript 设计的，但是在使用各种 JavaScript 的预编译语言时(如 TypeScript 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 文件 #  [建议] JavaScript 文件使用无 BOM 的 UTF-8 编码。 #  解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n[建议] 在文件结尾处，保留一个空行。 #  2.2 结构 #  2.2.1 缩进 #  [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 #  [强制] switch 下的 case 和 default 必须增加一个缩进层级。 #  示例：\n// good switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } // bad switch (variable) { case \u0026#34;1\u0026#34;: // do...  break; case \u0026#34;2\u0026#34;: // do...  break; default: // do... } 2.2.2 空格 #  [强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。 #  示例：\nvar a = !arr.length; a++; a = b + c; [强制] 用作代码块起始的左花括号 { 前必须有一个空格。 #  示例：\n// good if (condition) { } while (condition) {} function funcName() {} // bad if (condition) { } while (condition) {} function funcName() {} [强制] if / else / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格。 #  示例：\n// good if (condition) { } while (condition) {} (function() {})(); // bad if (condition) { } while (condition) {} (function() {})(); [强制] 在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。 #  示例：\n// good var obj = { a: 1, b: 2, c: 3 }; // bad var obj = { a: 1, b: 2, c: 3 }; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。 #  示例：\n// good function funcName() {} var funcName = function funcName() {}; funcName(); // bad function funcName() {} var funcName = function funcName() {}; funcName(); [强制] , 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。 #  示例：\n// good callFunc(a, b); // bad callFunc(a, b); [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。 #  示例：\n// good  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncream \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} // bad  callFunc(param1, param2, param3); save(this.list[this.indexes[i]]); needIncreament \u0026amp;\u0026amp; (variable += increament); if (num \u0026gt; list.length) { } while (len--) {} [强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。 #  解释：\n声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。\n示例：\n// good var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; // bad var arr1 = []; var arr2 = [1, 2, 3]; var obj1 = {}; var obj2 = { name: \u0026#34;obj\u0026#34; }; var obj3 = { name: \u0026#34;obj\u0026#34;, age: 20, sex: 1 }; [强制] 行尾不得有多余的空格。 #  2.2.3 换行 #  [强制] 每个独立语句结束后必须换行。 #  [强制] 每行不得超过 120 个字符。 #  解释：\n超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。\n[强制] 运算符处换行时，运算符必须在新行的行首。 #  示例：\n// good if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; // bad if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } var result = number1 + number2 + number3 + number4 + number5; [强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。 #  示例：\n// good var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // bad var obj = { a: 1, b: 2, c: 3 }; foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。 #  示例：\n// 仅为按逻辑换行的示例，不代表setStyle的最优实现 function setStyle(element, property, value) { if (element == null) { return; } element.style[property] = value; } [建议] 在语句的行长度超过 120 时，根据逻辑条件合理缩进。 #  示例：\n// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。 // 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。 if ( (user.isAuthenticated() \u0026amp;\u0026amp; user.isInRole(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; user.hasAuthority(\u0026#34;add-admin\u0026#34;)) || user.hasAuthority(\u0026#34;delete-admin\u0026#34;) ) { // Code } // 按一定长度截断字符串，并使用 + 运算符进行连接。 // 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。 // 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。 var html = \u0026#34;\u0026#34; + // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐  \u0026#34;\u0026lt;article\u0026gt;\u0026#34; + \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/article\u0026gt;\u0026#34;; // 也可使用数组来进行拼接，相对 `+` 更容易调整缩进。 var html = [ \u0026#34;\u0026lt;article\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h1\u0026gt;Title here\u0026lt;/h1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026#34;, \u0026#34;\u0026lt;footer\u0026gt;Complete\u0026lt;/footer\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/article\u0026gt;\u0026#34; ]; html = html.join(\u0026#34;\u0026#34;); // 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。 // 所有参数必须增加一个缩进。 foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback); // 也可以按逻辑对参数进行组合。 // 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块 baidu.format(dateFormatTemplate, year, month, date, hour, minute, second); // 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。 // 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。 setTimeout(function() { alert(\u0026#34;hello\u0026#34;); }, 200); order.data.read( \u0026#34;id=\u0026#34; + me.model.id, function(data) { me.attchToModel(data.result); callback(); }, 300 ); // 链式调用较长时采用缩进进行调整。 $(\u0026#34;#items\u0026#34;) .find(\u0026#34;.selected\u0026#34;) .highlight() .end(); // 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。 var result = thisIsAVeryVeryLongCondition ? resultA : resultB; var result = condition ? thisIsAVeryVeryLongResult : resultB; // 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。 var array = [ { // ...  }, { // ...  } ]; [建议] 对于 if...else...、try...catch...finally 等语句，推荐使用在 } 号后添加一个换行 的风格，使代码层次结构更清晰，阅读性更好。 #  示例：\nif (condition) { // some statements; } else { // some statements; } try { // some statements; } catch (ex) { // some statements; } 2.2.4 语句 #  [强制] 不得省略语句结束的分号。 #  [强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。 #  示例：\n// good if (condition) { callFunc(); } // bad if (condition) callFunc(); if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。 #  示例：\n// good function funcName() {} // bad function funcName() {} // 如果是函数表达式，分号是不允许省略的。 var funcName = function() {}; [强制] IIFE 必须在函数表达式外添加 (，非 IIFE 不得在函数表达式外添加 (。 #  解释：\nIIFE = Immediately-Invoked Function Expression.\n额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。\n示例：\n// good var task = (function() { // Code  return result; })(); var func = function() {}; // bad var task = (function() { // Code  return result; })(); var func = function() {}; 2.3 命名 #  [强制] 变量 使用 Camel命名法。 #  示例：\nvar loadingModules = {}; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。 #  示例：\nvar HTML_ENTITY = {}; [强制] 函数 使用 Camel命名法。 #  示例：\nfunction stringFormat(source) {} [强制] 函数的 参数 使用 Camel命名法。 #  示例：\nfunction hear(theBells) {} [强制] 类 使用 Pascal命名法。 #  示例：\nfunction TextNode(options) {} [强制] 类的 方法 / 属性 使用 Camel命名法。 #  示例：\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。 #  示例：\nvar TargetState = { READING: 1, READED: 2, APPLIED: 3, READY: 4 }; [强制] 命名空间 使用 Camel命名法。 #  示例：\nequipments.heavyWeapons = {}; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。 #  示例：\nfunction XMLParser() {} function insertHTML(element, html) {} var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。 #  示例：\nfunction Engine(options) {} [建议] 函数名 使用 动宾短语。 #  示例：\nfunction getStyle(element) {} [建议] boolean 类型的变量使用 is 或 has 开头。 #  示例：\nvar isReady = false; var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。 #  示例：\nvar loadingData = ajax.get(\u0026#34;url\u0026#34;); loadingData.then(callback); 2.4 注释 #  2.4.1 单行注释 #  [强制] 必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 #  2.4.2 多行注释 #  [建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。 #  2.4.3 文档化注释 #  [强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。 #  解释：\n 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块  [强制] 文档注释前必须空一行。 #  [建议] 自文档化的文档说明 what，而不是 how。 #  2.4.4 类型定义 #  [强制] 类型定义都是以 { 开始, 以 } 结束。 #  解释：\n常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。\n类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。\n[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。 #     类型定义 语法示例 解释     String {string} \u0026ndash;   Number {number} \u0026ndash;   Boolean {boolean} \u0026ndash;   Object {Object} \u0026ndash;   Function {Function} \u0026ndash;   RegExp {RegExp} \u0026ndash;   Array {Array} \u0026ndash;   Date {Date} \u0026ndash;   单一类型集合 {Array.\u0026lt;string\u0026gt;} string 类型的数组   多类型 {(number ｜ boolean)} 可能是 number 类型, 也可能是 boolean 类型   允许为 null {?number} 可能是 number, 也可能是 null   不允许为 null {!Object} Object 类型, 但不是 null   Function 类型 {function(number, boolean)} 函数, 形参类型   Function 带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型   Promise Promise.\u0026lt;resolveType, rejectType\u0026gt; Promise，成功返回的数据类型，失败返回的错误类型   参数可选 @param {string=} name 可选参数, =为类型后缀   可变参数 @param {\u0026hellip;number} args 变长参数, \u0026hellip;为类型前缀   任意类型 {*} 任意类型   可选任意类型 @param {*=} name 可选参数，类型不限   可变任意类型 @param {\u0026hellip;*} args 变长参数，类型不限    2.4.5 文件注释 #  [强制] 文件顶部必须包含文件注释，用 @file 标识文件说明。 #  示例：\n/** * @file Describe the file */ [建议] 文件注释中可以用 @author 标识开发者信息。 #  解释：\n开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入 @author 标识。\n@author 标识具有多人时，原则是按照 责任 进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加 @author 标识应该把自己的名字添加在创建人的前面。\n@author 中的名字不允许被删除。任何劳动成果都应该被尊重。\n业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加 @author 标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与 wiki 跟踪和查询，是更好的责任管理方式。\n对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用 @author 标识。\n示例：\n/** * @file Describe the file * @author author-name(mail-name@domain.com) * author-name2(mail-name2@domain.com) */ 2.4.6 命名空间注释 #  [建议] 命名空间使用 @namespace 标识。 #  示例：\n/** * @namespace */ var util = {}; 2.4.7 类注释 #  [建议] 使用 @class 标记类或构造函数。 #  解释：\n对于使用对象 constructor 属性来定义的构造函数，可以使用 @constructor 来标记。\n示例：\n/** * 描述 * * @class */ function Developer() { // constructor body } [建议] 使用 @extends 标记类的继承信息。 #  示例：\n/** * 描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.inherits(Fronteer, Developer); [强制] 使用包装方式扩展类成员时， 必须通过 @lends 进行重新指向。 #  解释：\n没有 @lends 标记将无法为该类生成包含扩展类成员的文档。\n示例：\n/** * 类描述 * * @class * @extends Developer */ function Fronteer() { Developer.call(this); // constructor body } util.extend( Fronteer.prototype, /** @lends Fronteer.prototype */ { getLevel: function() { // TODO  } } ); [强制] 类的属性或方法等成员信息不是 public 的，应使用 @protected 或 @private 标识可访问性。 #  解释：\n生成的文档中将有可访问性的标记，避免用户直接使用非 public 的属性或方法。\n示例：\n/** * 类描述 * * @class * @extends Developer */ var Fronteer = function() { Developer.call(this); /** * 属性描述 * * @type {string} * @private */ this.level = \u0026#34;T12\u0026#34;; // constructor body }; util.inherits(Fronteer, Developer); /** * 方法描述 * * @private * @return {string} 返回值描述 */ Fronteer.prototype.getLevel = function() {}; 2.4.8 函数/方法注释 #  [强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。 #  解释：\n当 return 关键字仅作退出函数/方法使用时，无须对返回值作注释标识。\n[强制] 参数和返回值注释必须包含类型信息，且不允许省略参数的说明。 #  [建议] 当函数是内部函数，外部不可访问时，可以使用 @inner 标识。 #  示例：\n/** * 函数描述 * * @param {string} p1 参数1的说明 * @param {string} p2 参数2的说明，比较长 * 那就换行了. * @param {number=} p3 参数3的说明（可选） * @return {Object} 返回值描述 */ function foo(p1, p2, p3) { var p3 = p3 || 10; return { p1: p1, p2: p2, p3: p3 }; } [强制] 对 Object 中各项的描述， 必须使用 @param 标识。 #  示例：\n/** * 函数描述 * * @param {Object} option 参数描述 * @param {string} option.url option项描述 * @param {string=} option.method option项描述，可选参数 */ function foo(option) { // TODO } [建议] 重写父类方法时， 应当添加 @override 标识。如果重写的形参个数、类型、顺序和返回值类型均未发生变化，可省略 @param、@return，仅用 @override 标识，否则仍应作完整注释。 #  解释：\n简而言之，当子类重写的方法能直接套用父类的方法注释时可省略对参数与返回值的注释。\n2.4.9 事件注释 #  [强制] 必须使用 @event 标识事件，事件参数的标识与方法描述的参数标识相同。 #  示例：\n/** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); [强制] 在会广播事件的函数前使用 @fires 标识广播的事件，在广播事件代码前使用 @event 标识事件。 #  [建议] 对于事件对象的注释，使用 @param 标识，生成文档时可读性更好。 #  示例：\n/** * 点击处理 * * @fires Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; 2.4.10 常量注释 #  [强制] 常量必须使用 @const 标记，并包含说明和类型信息。 #  示例：\n/** * 常量说明 * * @const * @type {string} */ var REQUEST_URL = \u0026#34;myurl.do\u0026#34;; 2.4.11 复杂类型注释 #  [建议] 对于类型未定义的复杂结构的注释，可以使用 @typedef 标识来定义。 #  示例：\n// `namespaceA~` 可以换成其它 namepaths 前缀，目的是为了生成文档中能显示 `@typedef` 定义的类型和链接。 /** * 服务器 * * @typedef {Object} namespaceA~Server * @property {string} host 主机 * @property {number} port 端口 */ /** * 服务器列表 * * @type {Array.\u0026lt;namespaceA~Server\u0026gt;} */ var servers = [ { host: \u0026#34;1.2.3.4\u0026#34;, port: 8080 }, { host: \u0026#34;1.2.3.5\u0026#34;, port: 8081 } ]; 2.4.12 AMD 模块注释 #  [强制] AMD 模块使用 @module 或 @exports 标识。 #  解释：\n@exports 与 @module 都可以用来标识模块，区别在于 @module 可以省略模块名称。而只使用 @exports 时在 namepaths 中可以省略 module: 前缀。\n示例：\ndefine(function(require) { /** * foo description * * @exports Foo */ var foo = { // TODO  }; /** * baz description * * @return {boolean} return description */ foo.baz = function() { // TODO  }; return foo; }); 也可以在 exports 变量前使用 @module 标识：\ndefine(function(require) { /** * module description. * * @module foo */ var exports = {}; /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); 如果直接使用 factory 的 exports 参数，还可以：\n/** * module description. * * @module */ define(function(require, exports) { /** * bar description * */ exports.bar = function() { // TODO  }; return exports; }); [强制] 对于已使用 @module 标识为 AMD 模块 的引用，在 namepaths 中必须增加 module: 作前缀。 #  解释：\nnamepaths 没有 module: 前缀时，生成的文档中将无法正确生成链接。\n示例：\n/** * 点击处理 * * @fires module:Select#change * @private */ Select.prototype.clickHandler = function() { /** * 值变更时触发 * * @event module:Select#change * @param {Object} e e描述 * @param {string} e.before before描述 * @param {string} e.after after描述 */ this.fire(\u0026#34;change\u0026#34;, { before: \u0026#34;foo\u0026#34;, after: \u0026#34;bar\u0026#34; }); }; [建议] 对于类定义的模块，可以使用 @alias 标识构建函数。 #  示例：\n/** * A module representing a jacket. * @module jacket */ define(function() { /** * @class * @alias module:jacket */ var Jacket = function() {}; return Jacket; }); [建议] 多模块定义时，可以使用 @exports 标识各个模块。 #  示例：\n// one module define(\u0026#34;html/utils\u0026#34;, /** * Utility functions to ease working with DOM elements. * @exports html/utils */ function() { var exports = {}; return exports; }); // another module define(\u0026#34;tag\u0026#34;, /** @exports tag */ function() { var exports = {}; return exports; }); [建议] 对于 exports 为 Object 的模块，可以使用@namespace标识。 #  解释：\n使用 @namespace 而不是 @module 或 @exports 时，对模块的引用可以省略 module: 前缀。\n[建议] 对于 exports 为类名的模块，使用 @class 和 @exports 标识。 #  示例：\n// 只使用 @class Bar 时，类方法和属性都必须增加 @name Bar#methodName 来标识，与 @exports 配合可以免除这一麻烦，并且在引用时可以省去 module: 前缀。 // 另外需要注意类名需要使用 var 定义的方式。  /** * Bar description * * @see foo * @exports Bar * @class */ var Bar = function() { // TODO }; /** * baz description * * @return {(string|Array)} return description */ Bar.prototype.baz = function() { // TODO }; 2.4.13 细节注释 #  对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。\n[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。 #  示例：\nfunction foo(p1, p2, opt_p3) { // 这里对具体内部逻辑进行说明  // 说明太长需要换行  for (...) { .... } } [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记： #  解释：\n TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。  3 语言特性 #  3.1 变量 #  [强制] 变量、函数在使用前必须先定义。 #  解释：\n不通过 var 定义变量将导致变量污染全局环境。\n示例：\n// good var name = \u0026#34;MyName\u0026#34;; // bad name = \u0026#34;MyName\u0026#34;; 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。\n示例：\n/* globals jQuery */ var element = jQuery(\u0026#34;#element-id\u0026#34;); [强制] 每个 var 只能声明一个变量。 #  解释：\n一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。\n示例：\n// good var hangModules = []; var missModules = []; var visited = {}; // bad var hangModules = [], missModules = [], visited = {}; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。 #  解释：\n变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然 JavaScript 的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。\n示例：\n// good function kv2List(source) { var list = []; for (var key in source) { if (source.hasOwnProperty(key)) { var item = { k: key, v: source[key] }; list.push(item); } } return list; } // bad function kv2List(source) { var list = []; var key; var item; for (key in source) { if (source.hasOwnProperty(key)) { item = { k: key, v: source[key] }; list.push(item); } } return list; } 3.2 条件 #  [强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。 #  解释：\n使用 === 可以避免等于判断中隐式的类型转换。\n示例：\n// good if (age === 30) { // ...... } // bad if (age == 30) { // ...... } [建议] 尽可能使用简洁的表达式。 #  示例：\n// 字符串为空  // good if (!name) { // ...... } // bad if (name === \u0026#34;\u0026#34;) { // ...... } // 字符串非空  // good if (name) { // ...... } // bad if (name !== \u0026#34;\u0026#34;) { // ...... } // 数组非空  // good if (collection.length) { // ...... } // bad if (collection.length \u0026gt; 0) { // ...... } // 布尔不成立  // good if (!notTrue) { // ...... } // bad if (notTrue === false) { // ...... } // null 或 undefined  // good if (noValue == null) { // ...... } // bad if (noValue === null || typeof noValue === \u0026#34;undefined\u0026#34;) { // ...... } [建议] 按执行频率排列分支的顺序。 #  解释：\n按执行频率排列分支的顺序好处是：\n 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。  [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。 #  示例：\n// good switch (typeof variable) { case \u0026#34;object\u0026#34;: // ......  break; case \u0026#34;number\u0026#34;: case \u0026#34;boolean\u0026#34;: case \u0026#34;string\u0026#34;: // ......  break; } // bad var type = typeof variable; if (type === \u0026#34;object\u0026#34;) { // ...... } else if (type === \u0026#34;number\u0026#34; || type === \u0026#34;boolean\u0026#34; || type === \u0026#34;string\u0026#34;) { // ...... } [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。 #  示例：\n// good function getName() { if (name) { return name; } return \u0026#34;unnamed\u0026#34;; } // bad function getName() { if (name) { return name; } else { return \u0026#34;unnamed\u0026#34;; } } 3.3 循环 #  [建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。 #  解释：\n循环体中的函数表达式，运行过程中会生成循环次数个函数对象。\n示例：\n// good function clicker() { // ...... } for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, clicker); } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; addListener(element, \u0026#34;click\u0026#34;, function() {}); } [建议] 对循环内多次使用的不变值，在循环外用变量缓存。 #  示例：\n// good var width = wrap.offsetWidth + \u0026#34;px\u0026#34;; for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = width; // ...... } // bad for (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; element.style.width = wrap.offsetWidth + \u0026#34;px\u0026#34;; // ...... } [建议] 对有序集合进行遍历时，缓存 length。 #  解释：\n虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。\n示例：\nfor (var i = 0, len = elements.length; i \u0026lt; len; i++) { var element = elements[i]; // ...... } [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。 #  解释：\n逆序遍历可以节省变量，代码比较优化。\n示例：\nvar len = elements.length; while (len--) { var element = elements[len]; // ...... } 3.4 类型 #  3.4.1 类型检测 #  [建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。 #  示例：\n// string typeof variable === \u0026#34;string\u0026#34;; // number typeof variable === \u0026#34;number\u0026#34;; // boolean typeof variable === \u0026#34;boolean\u0026#34;; // Function typeof variable === \u0026#34;function\u0026#34;; // Object typeof variable === \u0026#34;object\u0026#34;; // RegExp variable instanceof RegExp; // Array variable instanceof Array; // null variable === null; // null or undefined variable == null; // undefined typeof variable === \u0026#34;undefined\u0026#34;; 3.4.2 类型转换 #  [建议] 转换成 string 时，使用 + ''。 #  示例：\n// good num + \u0026#34;\u0026#34;; // bad new String(num); num.toString(); String(num); [建议] 转换成 number 时，通常使用 +。 #  示例：\n// good +str; // bad Number(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。 #  示例：\nvar width = \u0026#34;200px\u0026#34;; parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。 #  示例：\n// good parseInt(str, 10); // bad parseInt(str); [建议] 转换成 boolean 时，使用 !!。 #  示例：\nvar num = 3.14; !!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。 #  示例：\n// good var num = 3.14; Math.ceil(num); // bad var num = 3.14; parseInt(num, 10); 3.5 字符串 #  [强制] 字符串开头和结束使用单引号 '。 #  解释：\n 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。  示例：\nvar str = \u0026#34;我是一个字符串\u0026#34;; var html = \u0026#39;\u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;拼接HTML可以省去双引号转义\u0026lt;/div\u0026gt;\u0026#39;; [建议] 使用 数组 或 + 拼接字符串。 #  解释：\n 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。  示例：\n// 使用数组拼接字符串 var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读.  \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39; ].join(\u0026#39;\u0026#39;); // 使用 `+` 拼接字符串 var str2 = \u0026#39;\u0026#39; // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读  + \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第一项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;li\u0026gt;第二项\u0026lt;/li\u0026gt;\u0026#39;, + \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;; [建议] 使用字符串拼接的方式生成 HTML，需要根据语境进行合理的转义。 #  解释：\n在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。下面的示例代码为场景说明，不能直接运行。\n示例：\n// HTML 转义 var str = \u0026#34;\u0026lt;p\u0026gt;\u0026#34; + htmlEncode(content) + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; // HTML 转义 var str = \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#39; + htmlEncode(value) + \u0026#39;\u0026#34;\u0026gt;\u0026#39;; // URL 转义 var str = \u0026#39;\u0026lt;a href=\u0026#34;/?key=\u0026#39; + htmlEncode(urlEncode(value)) + \u0026#39;\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;\u0026#39;; // JavaScript字符串 转义 + HTML 转义 var str = \u0026#34;\u0026lt;button onclick=\\\u0026#34;check(\u0026#39;\u0026#34; + htmlEncode(strLiteral(name)) + \u0026#34;\u0026#39;)\\\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt;\u0026#34;; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。 #  解释：\n使用模板引擎有如下好处：\n 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行 HTML 转义，安全性更好。   artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。  3.6 对象 #  [强制] 使用对象字面量 {} 创建新 Object。 #  示例：\n// good var obj = {}; // bad var obj = new Object(); [建议] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。 #  示例：\nvar info = { name: \u0026#34;someone\u0026#34;, age: 28 }; [建议] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 '。 #  解释：\n如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。\n示例：\n// good var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; // bad var info = { name: \u0026#34;someone\u0026#34;, age: 28, \u0026#34;more-info\u0026#34;: \u0026#34;...\u0026#34; }; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。 #  示例：\n// 以下行为绝对禁止 String.prototype.trim = function() {}; [建议] 属性访问时，尽量使用 .。 #  解释：\n属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。\n通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性（比如来自后端的 JSON ），可能采用不寻常的命名方式，可以通过 [expr] 方式访问。\n示例：\ninfo.age; info[\u0026#34;more-info\u0026#34;]; [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。 #  示例：\nvar newInfo = {}; for (var key in info) { if (info.hasOwnProperty(key)) { newInfo[key] = info[key]; } } 3.7 数组 #  [强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。 #  示例：\n// good var arr = []; // bad var arr = new Array(); [强制] 遍历数组不使用 for in。 #  解释：\n数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果。\n示例：\nvar arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; // 这里仅作演示, 实际中应使用 Object 类型 arr.other = \u0026#34;other things\u0026#34;; // 正确的遍历方式 for (var i = 0, len = arr.length; i \u0026lt; len; i++) { console.log(i); } // 错误的遍历方式 for (var i in arr) { console.log(i); } [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。 #  解释：\n自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序：\n 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。  [建议] 清空数组使用 .length = 0。 #  3.8 函数 #  3.8.1 函数长度 #  [建议] 一个函数的长度控制在 50 行以内。 #  解释：\n将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。\n特定算法等不可分割的逻辑允许例外。\n示例：\nfunction syncViewStateOnUserAction() { if (x.checked) { y.checked = true; z.value = \u0026#34;\u0026#34;; } else { y.checked = false; } if (a.value) { warning.innerText = \u0026#34;\u0026#34;; submitButton.disabled = false; } else { warning.innerText = \u0026#34;Please enter it\u0026#34;; submitButton.disabled = true; } } // 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：  function syncViewStateOnUserAction() { syncXStateToView(); checkAAvailability(); } function syncXStateToView() { y.checked = x.checked; if (x.checked) { z.value = \u0026#34;\u0026#34;; } } function checkAAvailability() { if (a.value) { clearWarnignForA(); } else { displayWarningForAMissing(); } } 3.8.2 参数设计 #  [建议] 一个函数的参数控制在 6 个以内。 #  解释：\n除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。\n某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。\n[建议] 通过 options 参数传递非数据输入型参数。 #  解释：\n有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。\n如下函数：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {boolean} removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, removeEventListeners) { element.parent.removeChild(element); if (removeEventListeners) { element.clearEventListeners(); } } 可以转换为下面的签名：\n/** * 移除某个元素 * * @param {Node} element 需要移除的元素 * @param {Object} options 相关的逻辑配置 * @param {boolean} options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */ function removeElement(element, options) { element.parent.removeChild(element); if (options.removeEventListeners) { element.clearEventListeners(); } } 这种模式有几个显著的优势：\n boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。  3.8.3 闭包 #  [建议] 在适当的时候将闭包内大对象置为 null。 #  解释：\n在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。\n闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。\n首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收：\n 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用 eval。 是否使用了 with 表达式。  Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而 JScript.dll 和 Carakan 则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。\n由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时：\n 如果 fn 的 [[Scope]] 是 ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则：  如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。   获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody：  如果 FunctionBody 中含有 直接调用 eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。   检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则：  如果是 V8 引擎，删除该绑定。 如果是 SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。    对于 Chakra 引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。\n如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。\n[建议] 使用 IIFE 避免 Lift 效应。 #  解释：\n在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { tasks[tasks.length] = function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; } var len = tasks.length; while (len--) { tasks[len](); } 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。\n此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系：\nvar tasks = []; for (var i = 0; i \u0026lt; 5; i++) { // 注意有一层额外的闭包  tasks[tasks.length] = (function(i) { return function() { console.log(\u0026#34;Current cursor is at \u0026#34; + i); }; })(i); } var len = tasks.length; while (len--) { tasks[len](); } 3.8.4 空函数 #  [建议] 空函数不使用 new Function() 的形式。 #  示例：\nvar emptyFunction = function() {}; [建议] 对于性能有高要求的场合，建议存在一个空函数的常量，供多处使用共享。 #  示例：\nvar EMPTY_FUNCTION = function() {}; function MyClass() {} MyClass.prototype.abstractMethod = EMPTY_FUNCTION; MyClass.prototype.hooks.before = EMPTY_FUNCTION; MyClass.prototype.hooks.after = EMPTY_FUNCTION; 3.9 面向对象 #  [强制] 类的继承方案，实现时需要修正 constructor。 #  解释：\n通常使用其他 library 的类继承方案都会进行 constructor 修正。如果是自己实现的类继承方案，需要进行 constructor 修正。\n示例：\n/** * 构建类之间的继承关系 * * @param {Function} subClass 子类函数 * @param {Function} superClass 父类函数 */ function inherits(subClass, superClass) { var F = new Function(); F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; } [建议] 声明类时，保证 constructor 的正确性。 #  示例：\nfunction Animal(name) { this.name = name; } // 直接prototype等于对象时，需要修正constructor Animal.prototype = { constructor: Animal, jump: function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); } }; // 这种方式扩展prototype则无需理会constructor Animal.prototype.jump = function() { alert(\u0026#34;animal \u0026#34; + this.name + \u0026#34; jump\u0026#34;); }; [建议] 属性在构造函数中声明，方法在原型中声明。 #  解释：\n原型对象的成员被所有实例共享，能节约内存占用。所以编码时我们应该遵守这样的原则：原型对象包含程序不会修改的成员，如方法函数或配置项。\nfunction TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 自定义事件的 事件名 必须全小写。 #  解释：\n在 JavaScript 广泛应用的浏览器环境，绝大多数 DOM 事件名称都是全小写的。为了遵循大多数 JavaScript 开发者的习惯，在设计自定义事件时，事件名也应该全小写。\n[强制] 自定义事件只能有一个 event 参数。如果事件需要传递较多信息，应仔细设计事件对象。 #  解释：\n一个事件对象的好处有：\n 顺序无关，避免事件监听者需要记忆参数顺序。 每个事件信息都可以根据需要提供或者不提供，更自由。 扩展方便，未来添加事件信息时，无需考虑会破坏监听器参数形式而无法向后兼容。  [建议] 设计自定义事件时，应考虑禁止默认行为。 #  解释：\n常见禁止默认行为的方式有两种：\n 事件监听函数中 return false。 事件对象中包含禁止默认行为的方法，如 preventDefault。  3.10 动态特性 #  3.10.1 eval #  [强制] 避免使用直接 eval 函数。 #  解释：\n直接 eval，指的是以函数方式调用 eval 的调用方法。直接 eval 调用执行代码的作用域为本地作用域，应当避免。\n如果有特殊情况需要使用直接 eval，需在代码中用详细的注释说明为何必须使用直接 eval，不能使用其它动态执行代码的方式，同时需要其他资深工程师进行 Code Review。\n[建议] 尽量避免使用 eval 函数。 #  3.10.2 动态执行代码 #  [建议] 使用 new Function 执行动态代码。 #  解释：\n通过 new Function 生成的函数作用域是全局使用域，不会影响当当前的本地作用域。如果有动态代码执行的需求，建议使用 new Function。\n示例：\nvar handler = new Function(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;return x + y;\u0026#34;); var result = handler($(\u0026#34;#x\u0026#34;).val(), $(\u0026#34;#y\u0026#34;).val()); 3.10.3 with #  [建议] 尽量不要使用 with。 #  解释：\n使用 with 可能会增加代码的复杂度，不利于阅读和管理；也会对性能有影响。大多数使用 with 的场景都能使用其他方式较好的替代。所以，尽量不要使用 with。\n3.10.4 delete #  [建议] 减少 delete 的使用。 #  解释：\n如果没有特别的需求，减少或避免使用 delete。delete 的使用会破坏部分 JavaScript 引擎的性能优化。\n[建议] 处理 delete 可能产生的异常。 #  解释：\n对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。\n在严格模式或 IE 下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。\n示例：\ntry { delete o.x; } catch (deleteError) { o.x = null; } 3.10.5 对象属性 #  [建议] 避免修改外部传入的对象。 #  解释：\nJavaScript 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。\n但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。\n下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。\nfunction Tree(datasource) { this.datasource = datasource; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { node.selected = true; this.flushView(); } }; 对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。\nfunction Tree(datasource) { this.datasource = datasource; this.selectedNodeIndex = {}; } Tree.prototype.selectNode = function(id) { // 从datasource中找出节点对象  var node = this.findNode(id); if (node) { this.selectedNodeIndex[id] = true; this.flushView(); } }; 除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。\n[建议] 具备强类型的设计。 #  解释：\n 如果一个属性被设计为 boolean 类型，则不要使用 1 或 0 作为其值。对于标识性的属性，如对代码体积有严格要求，可以从一开始就设计为 number 类型且将 0 作为否定值。 从 DOM 中取出的值通常为 string 类型，如果有对象或函数的接收类型为 number 类型，提前作好转换，而不是期望对象、函数可以处理多类型的值。  4 浏览器环境 #  4.1 模块化 #  4.1.1 AMD #  [强制] 使用 AMD 作为模块定义。 #  解释：\nAMD 作为由社区认可的模块定义形式，提供多种重载提供灵活的使用方式，并且绝大多数优秀的 Library 都支持 AMD，适合作为规范。\n目前，比较成熟的 AMD Loader 有：\n 官方实现的 requirejs 百度自己实现的 esl  [强制] 模块 id 必须符合标准。 #  解释：\n模块 id 必须符合以下约束条件：\n 类型为 string，并且是由 / 分割的一系列 terms 来组成。例如：this/is/a/module。 term 应该符合 [a-zA-Z0-9_-:]+ 规则。 不应该有 .js 后缀。 跟文件的路径保持一致。  4.1.2 define #  [建议] 定义模块时不要指明 id 和 dependencies。 #  解释：\n在 AMD 的设计思想里，模块名称是和所在路径相关的，匿名的模块更利于封包和迁移。模块依赖应在模块定义内部通过 local require 引用。\n所以，推荐使用 define(factory) 的形式进行模块定义。\n示例：\ndefine(function(require) {}); [建议] 使用 return 来返回模块定义。 #  解释：\n使用 return 可以减少 factory 接收的参数（不需要接收 exports 和 module），在没有 AMD Loader 的场景下也更容易进行简单的处理来伪造一个 Loader。\n示例：\ndefine(function(require) { var exports = {}; // ...  return exports; }); 4.1.3 require #  [强制] 全局运行环境中，require 必须以 async require 形式调用。 #  解释：\n模块的加载过程是异步的，同步调用并无法保证得到正确的结果。\n示例：\n// good require([\u0026#34;foo\u0026#34;], function(foo) {}); // bad var foo = require(\u0026#34;foo\u0026#34;); [强制] 模块定义中只允许使用 local require，不允许使用 global require。 #  解释：\n 在模块定义中使用 global require，对封装性是一种破坏。 在 AMD 里，global require 是可以被重命名的。并且 Loader 甚至没有全局的 require 变量，而是用 Loader 名称做为 global require。模块定义不应该依赖使用的 Loader。  [强制] Package 在实现时，内部模块的 require 必须使用 relative id。 #  解释：\n对于任何可能通过 发布-引入 的形式复用的第三方库、框架、包，开发者所定义的名称不代表使用者使用的名称。因此不要基于任何名称的假设。在实现源码中，require 自身的其它模块时使用 relative id。\n示例：\ndefine(function(require) { var util = require(\u0026#34;./util\u0026#34;); }); [建议] 不会被调用的依赖模块，在 factory 开始处统一 require。 #  解释：\n有些模块是依赖的模块，但不会在模块实现中被直接调用，最为典型的是 css / js / tpl 等 Plugin 所引入的外部内容。此类内容建议放在模块定义最开始处统一引用。\n示例：\ndefine(function(require) { require(\u0026#34;css!foo.css\u0026#34;); require(\u0026#34;tpl!bar.tpl.html\u0026#34;); // ... }); 4.2 DOM #  4.2.1 元素获取 #  [建议] 对于单个元素，尽可能使用 document.getElementById 获取，避免使用document.all。 #  [建议] 对于多个元素的集合，尽可能使用 context.getElementsByTagName 获取。其中 context 可以为 document 或其他元素。指定 tagName 参数为 * 可以获得所有子元素。 #  [建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。 #  解释：\n原生获取元素集合的结果并不直接引用 DOM 元素，而是对索引进行读取，所以 DOM 结构的改变会实时反映到结果中。\n示例：\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; var elements = document.getElementsByTagName(\u0026#34;*\u0026#34;); // 显示为 DIV  alert(elements[0].tagName); var div = elements[0]; var p = document.createElement(\u0026#34;p\u0026#34;); docpment.body.insertBefore(p, div); // 显示为 P  alert(elements[0].tagName); \u0026lt;/script\u0026gt; [建议] 获取元素的直接子元素时使用 children。避免使用childNodes，除非预期是需要包含文本、注释和属性类型的节点。 #  4.2.2 样式获取 #  [建议] 获取元素实际样式信息时，应使用 getComputedStyle 或 currentStyle。 #  解释：\n通过 style 只能获得内联定义或通过 JavaScript 直接设置的样式。通过 CSS class 设置的元素样式无法直接通过 style 获取。\n4.2.3 样式设置 #  [建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。 #  [强制] 通过 style 对象设置元素样式时，对于带单位非 0 值的属性，不允许省略单位。 #  解释：\n除了 IE，标准浏览器会忽略不规范的属性值，导致兼容性问题。\n4.2.4 DOM 操作 #  [建议] 操作 DOM 时，尽量减少页面 reflow。 #  解释：\n页面 reflow 是非常耗时的行为，非常容易导致性能瓶颈。下面一些场景会触发浏览器的 reflow：\n DOM 元素的添加、修改（内容）、删除。 应用新的样式或者修改任何影响元素布局的属性。 Resize 浏览器窗口、滚动页面。 读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE)) 。  [建议] 尽量减少 DOM 操作。 #  解释：\nDOM 操作也是非常耗时的一种操作，减少 DOM 操作有助于提高性能。举一个简单的例子，构建一个列表。我们可以用两种方式：\n 在循环体中 createElement 并 append 到父元素中。 在循环体中拼接 HTML 字符串，循环结束后写父元素的 innerHTML。  第一种方法看起来比较标准，但是每次循环都会对 DOM 进行操作，性能极低。在这里推荐使用第二种方法。\n4.2.5 DOM 事件 #  [建议] 优先使用 addEventListener / attachEvent 绑定事件，避免直接在 HTML 属性中或 DOM 的 expando 属性绑定事件处理。 #  解释：\nexpando 属性绑定事件容易导致互相覆盖。\n[建议] 使用 addEventListener 时第三个参数使用 false。 #  解释：\n标准浏览器中的 addEventListener 可以通过第三个参数指定两种时间触发模型：冒泡和捕获。而 IE 的 attachEvent 仅支持冒泡的事件触发。所以为了保持一致性，通常 addEventListener 的第三个参数都为 false。\n[建议] 在没有事件自动管理的框架支持下，应持有监听器函数的引用，在适当时候（元素释放、页面卸载等）移除添加的监听器。 #  "}),a.add({id:3,href:'/study-javascript/docs/basic/practice/spec/baidu/',title:"百度前端编程规范",section:"编程规范",content:"百度前端编程规范 #  "}),a.add({id:4,href:'/study-javascript/docs/basic/practice/spec/',title:"编程规范",section:"实践",content:"编程规范 #  "}),a.add({id:5,href:'/study-javascript/docs/appendix/interview/basic/',title:"基础",section:"4.2 面试题",content:"基础面试题 #  "}),a.add({id:6,href:'/study-javascript/docs/appendix/interview/advanced/',title:"进阶",section:"4.2 面试题",content:"进阶面试题 #  "}),a.add({id:7,href:'/study-javascript/docs/appendix/interview/expert/',title:"高阶",section:"4.2 面试题",content:"高阶面试题 #  "}),a.add({id:8,href:'/study-javascript/docs/basic/practice/snippet/',title:"代码片段",section:"实践",content:"代码片段 #  sleep #  async function test() { console.log(\u0026#34;Hello\u0026#34;); await sleep(1000); console.log(\u0026#34;world!\u0026#34;); } function sleep(ms) { return new Promise((resolve) =\u0026gt; setTimeout(resolve, ms)); } test(); 参考：\n Javascript 如何能简短优雅地实现 sleep 函数？  "}),a.add({id:9,href:'/study-javascript/docs/appendix/interview/',title:"4.2 面试题",section:"第四部分 附录",content:"面试题 #  基础题 #  进阶题 #   如何衡量一个人的 JavaScript 水平？  "}),a.add({id:10,href:'/study-javascript/docs/appendix/attention/',title:"4.3 关注项目",section:"第四部分 附录",content:"关注项目 #  octokit/rest.js #  GitHub REST API client for JavaScript https://octokit.github.io/rest.js/\n"}),a.add({id:11,href:'/study-javascript/docs/basic/practice/spec/baidu/css/',title:"Css",section:"百度前端编程规范",content:"CSS 编码规范 #  1 前言\n2 代码风格\n2.1 文件\n2.2 缩进\n2.3 空格\n2.4 行长度\n2.5 选择器\n2.6 属性\n3 通用\n3.1 选择器\n3.2 属性缩写\n3.3 属性书写顺序\n3.4 清除浮动\n3.5 !important\n3.6 z-index\n4 值与单位\n4.1 文本\n4.2 数值\n4.3 url()\n4.4 长度\n4.5 颜色\n4.6 2D 位置\n5 文本编排\n5.1 字体族\n5.2 字号\n5.3 字体风格\n5.4 字重\n5.5 行高\n6 变换与动画\n7 响应式\n8 兼容性\n8.1 属性前缀\n8.2 Hack\n8.3 Expression\n1 前言 #  CSS 作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使 CSS 代码风格保持一致，容易被理解和被维护。\n虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 文件 #  [建议] CSS 文件使用无 BOM 的 UTF-8 编码。 #  解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n2.2 缩进 #  [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 #  示例：\n.selector { margin: 0; padding: 0; } 2.3 空格 #  [强制] 选择器 与 { 之间必须包含空格。 #  示例：\n.selector { } [强制] 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 #  示例：\nmargin: 0; [强制] 列表型属性值 书写在单行时，, 后必须跟一个空格。 #  示例：\nfont-family: Arial, sans-serif; 2.4 行长度 #  [强制] 每行不得超过 120 个字符，除非单行不可分割。 #  解释：\n常见不可分割的场景为 URL 超长。\n[建议] 对于超长的样式，在样式值的 空格 处或 , 后换行，建议按逻辑分组。 #  示例：\n/* 不同属性值按逻辑分组 */ background: transparent url(aVeryVeryVeryLongUrlIsPlacedHere) no-repeat 0 0; /* 可重复多次的属性，每次重复一行 */ background-image: url(aVeryVeryVeryLongUrlIsPlacedHere) url(anotherVeryVeryVeryLongUrlIsPlacedHere); /* 类似函数的属性值可以根据函数调用的缩进进行 */ background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.04, rgb(88, 94, 124)), color-stop(0.52, rgb(115, 123, 162)) ); 2.5 选择器 #  [强制] 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 #  示例：\n/* good */ .post, .page, .comment { line-height: 1.5; } /* bad */ .post, .page, .comment { line-height: 1.5; } [强制] \u0026gt;、+、~ 选择器的两边各保留一个空格。 #  示例：\n/* good */ main \u0026gt; nav { padding: 10px; } label + input { margin-left: 5px; } input:checked ~ button { background-color: #69c; } /* bad */ main \u0026gt; nav { padding: 10px; } label + input { margin-left: 5px; } input:checked ~ button { background-color: #69c; } [强制] 属性选择器中的值必须用双引号包围。 #  解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n/* good */ article[character=\u0026#34;juliet\u0026#34;] { voice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female; } /* bad */ article[character=\u0026#34;juliet\u0026#34;] { voice-family: \u0026#34;Vivien Leigh\u0026#34;, victoria, female; } 2.6 属性 #  [强制] 属性定义必须另起一行。 #  示例：\n/* good */ .selector { margin: 0; padding: 0; } /* bad */ .selector { margin: 0; padding: 0; } [强制] 属性定义后必须以分号结尾。 #  示例：\n/* good */ .selector { margin: 0; } /* bad */ .selector { margin: 0; } 3 通用 #  3.1 选择器 #  [强制] 如无必要，不得为 id、class 选择器添加类型选择器进行限定。 #  解释：\n在性能和维护性上，都有一定的影响。\n示例：\n/* good */ #error, .danger-message { font-color: #c00; } /* bad */ dialog#error, p.danger-message { font-color: #c00; } [建议] 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 #  示例：\n/* good */ #username input { } .comment .avatar { } /* bad */ .page .header .login #username input { } .comment div * { } 3.2 属性缩写 #  [建议] 在可以使用缩写的情况下，尽量使用属性缩写。 #  示例：\n/* good */ .post { font: 12px/1.5 arial, sans-serif; } /* bad */ .post { font-family: arial, sans-serif; font-size: 12px; line-height: 1.5; } [建议] 使用 border / margin / padding 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。 #  解释：\nborder / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。\n示例：\n/* centering \u0026lt;article class=\u0026#34;page\u0026#34;\u0026gt; horizontally and highlight featured ones */ article { margin: 5px; border: 1px solid #999; } /* good */ .page { margin-right: auto; margin-left: auto; } .featured { border-color: #69c; } /* bad */ .page { margin: 5px auto; /* introducing redundancy */ } .featured { border: 1px solid #69c; /* introducing redundancy */ } 3.3 属性书写顺序 #  [建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） \u0026gt; Box Model（尺寸） \u0026gt; Typographic（文本相关） \u0026gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。 #  解释：\n Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等  另外，如果包含 content 属性，应放在最前面。\n示例：\n.sidebar { /* formatting model: positioning schemes / offsets / z-indexes / display / ... */ position: absolute; top: 50px; left: 0; overflow-x: hidden; /* box model: sizes / margins / paddings / borders / ... */ width: 200px; padding: 5px; border: 1px solid #ddd; /* typographic: font / aligns / text styles / ... */ font-size: 14px; line-height: 20px; /* visual: colors / shadows / gradients / ... */ background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s; } 3.4 清除浮动 #  [建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。 #  解释：\n触发 BFC 的方式很多，常见的有：\n float 非 none position 非 static overflow 非 visible  如希望使用更小副作用的清除浮动方法，参见 A new micro clearfix hack 一文。\n另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。\n3.5 !important #  [建议] 尽量不使用 !important 声明。 #  [建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。 #  解释：\n必须注意的是，仅在设计上 确实不允许任何其它场景覆盖样式 时，才使用内联的 !important 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。\n3.6 z-index #  [建议] 将 z-index 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。 #  解释：\n同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 z-index 或递增 z-index。\n建议每层包含 100 个 z-index 来容纳足够的元素，如果每层元素较多，可以调整这个数值。\n[建议] 在可控环境下，期望显示在最上层的元素，z-index 指定为 999999。 #  解释：\n可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。\n不建议取值为 2147483647。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。\n[建议] 在第三方环境下，期望显示在最上层的元素，通过标签内联和 !important，将 z-index 指定为 2147483647。 #  解释：\n第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。\n4 值与单位 #  4.1 文本 #  [强制] 文本内容必须用双引号包围。 #  解释：\n文本类型的内容可能在选择器、属性值等内容中。\n示例：\n/* good */ html[lang|=\u0026#34;zh\u0026#34;] q:before { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;“\u0026#34;; } html[lang|=\u0026#34;zh\u0026#34;] q:after { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;”\u0026#34;; } /* bad */ html[lang|=\u0026#34;zh\u0026#34;] q:before { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;“\u0026#34;; } html[lang|=\u0026#34;zh\u0026#34;] q:after { font-family: \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; content: \u0026#34;”\u0026#34;; } 4.2 数值 #  [强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。 #  示例：\n/* good */ panel { opacity: 0.8; } /* bad */ panel { opacity: 0.8; } 4.3 url() #  [强制] url() 函数中的路径不加引号。 #  示例：\nbody { background: url(bg.png); } [建议] url() 函数中的绝对路径可省去协议名。 #  示例：\nbody { background: url(//baidu.com/img/bg.png) no-repeat 0 0; } 4.4 长度 #  [强制] 长度为 0 时须省略单位。 (也只有长度单位可省) #  示例：\n/* good */ body { padding: 0 5px; } /* bad */ body { padding: 0px 5px; } 4.5 颜色 #  [强制] RGB 颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。 #  解释：\n带有 alpha 的颜色信息可以使用 rgba()。使用 rgba() 时每个逗号后必须保留一个空格。\n示例：\n/* good */ .success { box-shadow: 0 0 2px rgba(0, 128, 0, 0.3); border-color: #008000; } /* bad */ .success { box-shadow: 0 0 2px rgba(0, 128, 0, 0.3); border-color: rgb(0, 128, 0); } [强制] 颜色值可以缩写时，必须使用缩写形式。 #  示例：\n/* good */ .success { background-color: #aca; } /* bad */ .success { background-color: #aaccaa; } [强制] 颜色值不允许使用命名色值。 #  示例：\n/* good */ .success { color: #90ee90; } /* bad */ .success { color: lightgreen; } [建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。 #  示例：\n/* good */ .success { background-color: #aca; color: #90ee90; } /* good */ .success { background-color: #aca; color: #90ee90; } /* bad */ .success { background-color: #aca; color: #90ee90; } 4.6 2D 位置 #  [强制] 必须同时给出水平和垂直方向的位置。 #  解释：\n2D 位置初始值为 0% 0%，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。background-position 属性值的定义\n示例：\n/* good */ body { background-position: center top; /* 50% 0% */ } /* bad */ body { background-position: top; /* 50% 0% */ } 5 文本编排 #  5.1 字体族 #  [强制] font-family 属性中的字体族名称应使用字体的英文 Family Name，其中如有空格，须放置在引号中。 #  解释：\n所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：\n   字体 操作系统 Family Name     宋体 (中易宋体) Windows SimSun   黑体 (中易黑体) Windows SimHei   微软雅黑 Windows Microsoft YaHei   微软正黑 Windows Microsoft JhengHei   华文黑体 Mac/iOS STHeiti   冬青黑体 Mac/iOS Hiragino Sans GB   文泉驿正黑 Linux WenQuanYi Zen Hei   文泉驿微米黑 Linux WenQuanYi Micro Hei    示例：\nh1 { font-family: \u0026#34;Microsoft YaHei\u0026#34;; } [强制] font-family 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif )。 #  解释：\n更详细说明可参考本文。\n示例：\n/* Display according to platform */ .article { font-family: Arial, sans-serif; } /* Specific for most platforms */ h1 { font-family: \u0026#34;Helvetica Neue\u0026#34;, Arial, \u0026#34;Hiragino Sans GB\u0026#34;, \u0026#34;WenQuanYi Micro Hei\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } [强制] font-family 不区分大小写，但在同一个项目中，同样的 Family Name 大小写必须统一。 #  示例：\n/* good */ body { font-family: Arial, sans-serif; } h1 { font-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } /* bad */ body { font-family: arial, sans-serif; } h1 { font-family: Arial, \u0026#34;Microsoft YaHei\u0026#34;, sans-serif; } 5.2 字号 #  [强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。 #  解释：\n由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。\n5.3 字体风格 #  [建议] 需要在 Windows 平台显示的中文内容，不要使用除 normal 外的 font-style。其他平台也应慎用。 #  解释：\n由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。\n5.4 字重 #  [强制] font-weight 属性必须使用数值方式描述。 #  解释：\nCSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。\n浏览器本身使用一系列启发式规则来进行匹配，在 \u0026lt;700 时一般匹配字体的 Regular 字重，\u0026gt;=700 时匹配 Bold 字重。\n但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。\n示例：\n/* good */ h1 { font-weight: 700; } /* bad */ h1 { font-weight: bold; } 5.5 行高 #  [建议] line-height 在定义文本段落时，应使用数值。 #  解释：\n将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。\n当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。\n示例：\n.container { line-height: 1.5; } 6 变换与动画 #  [强制] 使用 transition 时应指定 transition-property。 #  示例：\n/* good */ .box { transition: color 1s, border-color 1s; } /* bad */ .box { transition: all 1s; } [建议] 尽可能在浏览器能高效实现的属性上添加过渡和动画。 #  解释：\n见 本文，在可能的情况下应选择这样四种变换：\n transform: translate(npx, npx); transform: scale(n); transform: rotate(ndeg); opacity: 0..1;  典型的，可以使用 translate 来代替 left 作为动画属性。\n示例：\n/* good */ .box { transition: transform 1s; } .box:hover { transform: translate(20px); /* move right for 20px */ } /* bad */ .box { left: 0; transition: left 1s; } .box:hover { left: 20px; /* move right for 20px */ } 7 响应式 #  [强制] Media Query 不得单独编排，必须与相关的规则一起定义。 #  示例：\n/* Good */ /* header styles */ @media (...) { /* header styles */ } /* main styles */ @media (...) { /* main styles */ } /* footer styles */ @media (...) { /* footer styles */ } /* Bad */ /* header styles */ /* main styles */ /* footer styles */ @media (...) { /* header styles */ /* main styles */ /* footer styles */ } [强制] Media Query 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。 #  示例：\n@media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */ (min--moz-device-pixel-ratio: 2), /* Older Firefox browsers (prior to firefox 16) */ (min-resolution: 2dppx), /* The standard way */ (min-resolution: 192dpi) { /* dppx fallback */ /* Retina-specific stuff here */ } [建议] 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。 #  8 兼容性 #  8.1 属性前缀 #  [强制] 带私有前缀的属性由长到短排列，按冒号位置对齐。 #  解释：\n标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。\n示例：\n.box { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } 8.2 Hack #  [建议] 需要添加 hack 时应尽可能考虑是否可以采用其他方式解决。 #  解释：\n如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。\n[建议] 尽量使用 选择器 hack 处理兼容性，而非 属性 hack。 #  解释：\n尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。\n示例：\n/* IE 7 */ *:first-child + html #header { margin-top: 3px; padding: 5px; } /* IE 6 */ * html #header { margin-top: 5px; padding: 4px; } [建议] 尽量使用简单的 属性 hack。 #  示例：\n.box { _display: inline; /* fix double margin */ float: left; margin-left: 20px; } .container { overflow: hidden; *zoom: 1; /* triggering hasLayout */ } 8.3 Expression #  [强制] 禁止使用 Expression。 #  "}),a.add({id:12,href:'/study-javascript/docs/basic/practice/spec/baidu/es-next/',title:"Es Next",section:"百度前端编程规范",content:"JavaScript 编码规范 - ESNext 补充篇（草案） #  1 前言\n2 代码风格\n2.1 文件\n2.2 结构\n2.2.1 缩进\n2.2.2 空格\n2.2.3 语句\n3 语言特性\n3.1 变量\n3.2 解构\n3.3 模板字符串\n3.4 函数\n3.5 箭头函数\n3.6 对象\n3.7 类\n3.8 模块\n3.9 集合\n3.10 异步\n4 环境\n4.1 运行环境\n4.2 预编译\n1 前言 #  随着 ECMAScript 的不断发展，越来越多更新的语言特性将被使用，给应用的开发带来方便。本文档的目标是使 ECMAScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档仅包含新特性部分。基础部分请遵循 JavaScript Style Guide。\n由于 ECMAScript 依然在快速的不断发展，本文档也将可能随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n虽然本文档是针对 ECMAScript 设计的，但是在使用各种基于 ECMAScript 扩展的语言时(如 JSX、TypeScript 等)，适用的部分也应尽量遵循本文档的约定。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 文件 #  [建议] ESNext 语法的 JavaScript 文件使用 .js 扩展名。 #  [强制] 当文件无法使用 .js 扩展名时，使用 .es 扩展名。 #  解释：\n某些应用开发时，可能同时包含 ES 5 和 ESNext 文件，运行环境仅支持 ES5，ESNext 文件需要经过预编译。部分场景下，编译工具的选择可能需要通过扩展名区分，需要重新定义 ESNext 文件的扩展名。此时，ESNext 文件必须使用 .es 扩展名。\n但是，更推荐使用其他条件作为是否需要编译的区分：\n 基于文件内容。 不同类型文件放在不同目录下。  2.2 结构 #  2.2.1 缩进 #  [建议] 使用多行模板字符串时遵循缩进原则。当空行与空白字符敏感时，不使用多行模板字符串。 #  解释：\n4 空格为一个缩进，换行后添加一层缩进。将起始和结束的 ` 符号单独放一行，有助于生成 HTML 时的标签对齐。\n为避免破坏缩进的统一，当空行与空白字符敏感时，建议使用 多个模板字符串 或 普通字符串 进行连接运算，也可使用数组 join 生成字符串。\n示例：\n// good function foo() { let html = ` \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; } // Good function greeting(name) { return \u0026#34;Hello, \\n\u0026#34; + `${name.firstName}${name.lastName}`; } // Bad function greeting(name) { return `Hello, ${name.firstName}${name.lastName}`; } 2.2.2 空格 #  [强制] 使用 generator 时，* 前面不允许有空格，* 后面必须有一个空格。 #  示例：\n// good function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } // bad function* caller() { yield \u0026#34;a\u0026#34;; yield* callee(); yield \u0026#34;d\u0026#34;; } 2.2.3 语句 #  [强制] 类声明结束不允许添加分号。 #  解释：\n与函数声明保持一致。\n[强制] 类成员定义中，方法定义后不允许添加分号，成员属性定义后必须添加分号。 #  解释：\n成员属性是当前 Stage 0 的标准，如果使用的话，则定义后加上分号。\n示例：\n// good class Foo { foo = 3; bar() {} } // bad class Foo { foo = 3; bar() {} } [强制] export 语句后，不允许出现表示空语句的分号。 #  解释：\nexport 关键字不影响后续语句类型。\n示例：\n// good export function foo() {} export default function bar() {} // bad export function foo() {} export default function bar() {} [强制] 属性装饰器后，可以不加分号的场景，不允许加分号。 #  解释：\n只有一种场景是必须加分号的：当属性 key 是 computed property key 时，其装饰器必须加分号，否则修饰 key 的 [] 会做为之前表达式的 property accessor。\n上面描述的场景，装饰器后需要加分号。其余场景下的属性装饰器后不允许加分号。\n示例：\n// good class Foo { @log(\u0026#39;INFO\u0026#39;) bar() { } @log(\u0026#39;INFO\u0026#39;); [\u0026#39;bar\u0026#39; + 2]() { } } // bad class Foo { @log(\u0026#39;INFO\u0026#39;); bar() { } @log(\u0026#39;INFO\u0026#39;) [\u0026#39;bar\u0026#39; + 2]() { } } [强制] 箭头函数的参数只有一个，并且不包含解构时，参数部分的括号必须省略。 #  示例：\n// good list.map(item =\u0026gt; item * 2); // good let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; // bad list.map(item =\u0026gt; item * 2); // bad let fetchName = async id =\u0026gt; { let user = await request(`users/${id}`); return user.fullName; }; [建议] 箭头函数的函数体只有一个单行表达式语句，且作为返回值时，省略 {} 和 return。 #  如果单个表达式过长，可以使用 () 进行包裹。\n示例：\n// good list.map(item =\u0026gt; item * 2); let foo = () =\u0026gt; (condition ? returnValueA() : returnValueB()); // bad list.map(item =\u0026gt; { return item * 2; }); [建议] 箭头函数的函数体只有一个 Object Literal，且作为返回值时，使用 () 包裹。 #  示例：\n// good list.map(item =\u0026gt; ({ name: item[0], email: item[1] })); [强制] 解构多个变量时，如果超过行长度限制，每个解构的变量必须单独一行。 #  解释：\n太多的变量解构会让一行的代码非常长，极有可能超过单行长度控制，使代码可读性下降。\n示例：\n// good let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; // bad let { name: personName, email: personEmail, sex: personSex, age: personAge } = person; [强制] 对于对象初始化、数组初始化、import及export语句，当其多个子元素占用多行时，最后一个元素后必须保留逗号。 #  解释：\nES Next 允许以上语法最后保留逗号，多行时保留逗号有助于快速添加或删除子元素。\n本条规则不适用于函数调用和声明的参数，函数最后一个参数不得包含逗号。\n示例：\n// good const array = [foo, bar]; const array = [foo, bar]; // 单行的最后没有逗号  const object = { foo: bar, x: y }; const object = { foo: bar }; // 单行的最后没有逗号  import { foo, bar } from \u0026#34;module\u0026#34;; import { foo, bar } from \u0026#34;module\u0026#34;; // 单行的最后没有逗号  export { foo, bar }; export { foo, bar }; // 单行的最后没有逗号  // bad  const array = [foo, bar]; const object = { foo: bar, x: y }; 3 语言特性 #  3.1 变量 #  [强制] 使用 let 和 const 定义变量，不使用 var。 #  解释：\n使用 let 和 const 定义时，变量作用域范围更明确。\n示例：\n// good for (let i = 0; i \u0026lt; 10; i++) {} // bad for (var i = 0; i \u0026lt; 10; i++) {} 3.2 解构 #  [强制] 不要使用 3 层及以上的解构。 #  解释：\n过多层次的解构会让代码变得难以阅读。\n示例：\n// bad let { documentElement: { firstElementChild: { nextSibling } } } = window; [建议] 使用解构减少中间变量。 #  解释：\n常见场景如变量值交换，可能产生中间变量。这种场景推荐使用解构。\n示例：\n// good [x, y] = [y, x]; // bad let temp = x; x = y; y = temp; [强制] 如果不节省编写时产生的中间变量，解构表达式 = 号右边不允许是 ObjectLiteral 和 ArrayLiteral。 #  解释：\n在这种场景下，使用解构将降低代码可读性，通常也并无收益。\n示例：\n// good let { first: firstName, last: lastName } = person; let one = 1; let two = 2; // bad let [one, two] = [1, 2]; [强制] 使用剩余运算符时，剩余运算符之前的所有元素必需具名。 #  解释：\n剩余运算符之前的元素省略名称可能带来较大的程序阅读障碍。如果仅仅为了取数组后几项，请使用 slice 方法。\n示例：\n// good let [one, two, ...anyOther] = myArray; let other = myArray.slice(3); // bad let [, , , ...other] = myArray; 3.3 模板字符串 #  [强制] 字符串内变量替换时，不要使用 2 次及以上的函数调用。 #  解释：\n在变量替换符内有太多的函数调用等复杂语法会导致可读性下降。\n示例：\n// good let fullName = getFullName(getFirstName(), getLastName()); let s = `Hello ${fullName}`; // bad let s = `Hello ${getFullName(getFirstName(), getLastName())}`; 3.4 函数 #  [建议] 使用变量默认语法代替基于条件判断的默认值声明。 #  解释：\n添加默认值有助于引擎的优化，在未来 strong mode 下也会有更好的效果。\n示例：\n// good function foo(text = \u0026#34;hello\u0026#34;) {} // bad function foo(text) { text = text || \u0026#34;hello\u0026#34;; } [强制] 不要使用 arguments 对象，应使用 ...args 代替。 #  解释：\n在未来 strong mode 下 arguments 将被禁用。\n示例：\n// good function foo(...args) { console.log(args.join(\u0026#34;\u0026#34;)); } // bad function foo() { console.log([].join.call(arguments)); } 3.5 箭头函数 #  [强制] 一个函数被设计为需要 call 和 apply 的时候，不能是箭头函数。 #  解释：\n箭头函数会强制绑定当前环境下的 this。\n3.6 对象 #  [强制] 定义方法时使用 MethodDefinition 语法，不使用 PropertyName: FunctionExpression 语法。 #  解释：\nMethodDefinition 语法更清晰简洁。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: function(x, y) { return x + y; } }; [建议] 使用 Object.keys 或 Object.entries 进行对象遍历。 #  解释：\n不建议使用 for .. in 进行对象的遍历，以避免遗漏 hasOwnProperty 产生的错误。\n示例：\n// good for (let key of Object.keys(foo)) { let value = foo[key]; } // good for (let [key, value] of Object.entries(foo)) { // ... } [建议] 定义对象的方法不应使用箭头函数。 #  解释：\n箭头函数将 this 绑定到当前环境，在 obj.method() 调用时容易导致不期待的 this。除非明确需要绑定 this，否则不应使用箭头函数。\n示例：\n// good let foo = { bar(x, y) { return x + y; } }; // bad let foo = { bar: (x, y) =\u0026gt; x + y }; [建议] 尽量使用计算属性键在一个完整的字面量中完整地定义一个对象，避免对象定义后直接增加对象属性。 #  解释：\n在一个完整的字面量中声明所有的键值，而不需要将代码分散开来，有助于提升代码可读性。\n示例：\n// good const MY_KEY = \u0026#34;bar\u0026#34;; let foo = { [MY_KEY + \u0026#34;Hash\u0026#34;]: 123 }; // bad const MY_KEY = \u0026#34;bar\u0026#34;; let foo = {}; foo[MY_KEY + \u0026#34;Hash\u0026#34;] = 123; 3.7 类 #  [强制] 使用 class 关键字定义一个类。 #  解释：\n直接使用 class 定义类更清晰。不要再使用 function 和 prototype 形式的定义。\n// good class TextNode { constructor(value, engine) { this.value = value; this.engine = engine; } clone() { return this; } } // bad function TextNode(value, engine) { this.value = value; this.engine = engine; } TextNode.prototype.clone = function() { return this; }; [强制] 使用 super 访问父类成员，而非父类的 prototype。 #  解释：\n使用 super 和 super.foo 可以快速访问父类成员，而不必硬编码父类模块而导致修改和维护的不便，同时更节省代码。\n// good class TextNode extends Node { constructor(value, engine) { super(value); this.engine = engine; } setNodeValue(value) { super.setNodeValue(value); this.textContent = value; } } // bad class TextNode extends Node { constructor(value, engine) { Node.apply(this, arguments); this.engine = engine; } setNodeValue(value) { Node.prototype.setNodeValue.call(this, value); this.textContent = value; } } 3.8 模块 #  [建议] 相互之间无关联的内容使用命名导出。 #  解释：\n举个例子，工具对象中的各个方法，相互之间并没有强关联，通常外部会选择几个使用，则应该使用命名导出。\n简而言之，当一个模块只扮演命名空间的作用时，使用命名导出。\n[强制] 所有 import 语句写在模块开始处。 #  示例：\n// good import { bar } from \u0026#34;./bar\u0026#34;; function foo() { bar.work(); } // bad function foo() { import { bar } from \u0026#34;./bar\u0026#34;; bar.work(); } 3.9 集合 #  [建议] 对数组进行连接操作时，使用数组展开语法。 #  解释：\n用数组展开代替 concat 方法，数组展开对 Iterable 有更好的兼容性。\n示例：\n// good let foo = [...foo, newValue]; let bar = [...bar, ...newValues]; // bad let foo = foo.concat(newValue); let bar = bar.concat(newValues); [建议] 不要使用数组展开进行数组的复制操作。 #  解释：\n使用数组展开语法进行复制，代码可读性较差。推荐使用 Array.from 方法进行复制操作。\n示例：\n// good let otherArr = Array.from(arr); // bad let otherArr = [...arr]; [建议] 尽可能使用 for .. of 进行遍历。 #  解释：\n使用 for .. of 可以更好地接受任何的 Iterable 对象，如 Map#values 生成的迭代器，使得方法的通用性更强。\n以下情况除外：\n 遍历确实成为了性能瓶颈，需要使用原生 for 循环提升性能。 需要遍历过程中的索引。  [强制] 当键值有可能不是字符串时，必须使用 Map；当元素有可能不是字符串时，必须使用 Set。 #  解释：\n使用普通 Object，对非字符串类型的 key，需要自己实现序列化。并且运行过程中的对象变化难以通知 Object。\n[建议] 需要一个不可重复的集合时，应使用 Set。 #  解释：\n不要使用 {foo: true} 这样的普通 Object。\n示例：\n// good let members = new Set([\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]); // bad let members = { one: true, two: true, three: true }; [建议] 当需要遍历功能时，使用 Map 和 Set。 #  解释：\nMap 和 Set 是可遍历对象，能够方便地使用 for...of 遍历。不要使用使用普通 Object。\n示例：\n// good let membersAge = new Map([ [\u0026#34;one\u0026#34;, 10], [\u0026#34;two\u0026#34;, 20], [\u0026#34;three\u0026#34;, 30] ]); for (let [key, value] of map) { } // bad let membersAge = { one: 10, two: 20, three: 30 }; for (let key in membersAge) { if (membersAge.hasOwnProperty(key)) { let value = membersAge[key]; } } [建议] 程序运行过程中有添加或移除元素的操作时，使用 Map 和 Set。 #  解释：\n使用 Map 和 Set，程序的可理解性更好；普通 Object 的语义更倾向于表达固定的结构。\n示例：\n// good let membersAge = new Map(); membersAge.set(\u0026#34;one\u0026#34;, 10); membersAge.set(\u0026#34;two\u0026#34;, 20); membersAge.set(\u0026#34;three\u0026#34;, 30); membersAge.delete(\u0026#34;one\u0026#34;); // bad let membersAge = {}; membersAge.one = 10; membersAge.two = 20; membersAge.three = 30; delete membersAge[\u0026#34;one\u0026#34;]; 3.10 异步 #  [强制] 回调函数的嵌套不得超过 3 层。 #  解释：\n深层次的回调函数的嵌套会让代码变得难以阅读。\n示例：\n// bad getUser(userId, function(user) { validateUser(user, function(isValid) { if (isValid) { saveReport(report, user, function() { notice(\u0026#34;Saved!\u0026#34;); }); } }); }); [建议] 使用 Promise 代替 callback。 #  解释：\n相比 callback，使用 Promise 能够使复杂异步过程的代码更清晰。\n示例：\n// good let user; getUser(userId) .then(function(userObj) { user = userObj; return validateUser(user); }) .then(function(isValid) { if (isValid) { return saveReport(report, user); } return Promise.reject(\u0026#34;Invalid!\u0026#34;); }) .then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); [强制] 使用标准的 Promise API。 #  解释：\n 不允许使用非标准的 Promise API，如 jQuery 的 Deferred、Q.js 的 defer 等。 不允许使用非标准的 Promise 扩展 API，如 bluebird 的 Promise.any 等。  使用标准的 Promise API，当运行环境都支持时，可以把 Promise Lib 直接去掉。\n[强制] 不允许直接扩展 Promise 对象的 prototype。 #  解释：\n理由和 不允许修改和扩展任何原生对象和宿主对象的原型 是一样的。如果想要使用更方便，可以用 utility 函数的形式。\n[强制] 不得为了编写的方便，将可以并行的 IO 过程串行化。 #  解释：\n并行 IO 消耗时间约等于 IO 时间最大的那个过程，串行的话消耗时间将是所有过程的时间之和。\n示例：\nrequestData().then(function(data) { renderTags(data.tags); renderArticles(data.articles); }); // good async function requestData() { const [tags, articles] = await Promise.all([ requestTags(), requestArticles() ]); return { tags, articles }; } // bad async function requestData() { let tags = await requestTags(); let articles = await requestArticles(); return Promise.resolve({ tags, articles }); } [建议] 使用 async/await 代替 generator + co。 #  解释：\n使用语言自身的能力可以使代码更清晰，也无需引入 co 库。\n示例：\naddReport(report, userId).then( function() { notice(\u0026#34;Saved!\u0026#34;); }, function(message) { notice(message); } ); // good async function addReport(report, userId) { let user = await getUser(userId); let isValid = await validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); } // bad function addReport(report, userId) { return co(function*() { let user = yield getUser(userId); let isValid = yield validateUser(user); if (isValid) { let savePromise = saveReport(report, user); return savePromise(); } return Promise.reject(\u0026#34;Invalid\u0026#34;); }); } 4 环境 #  4.1 运行环境 #  [建议] 持续跟进与关注运行环境对语言特性的支持程度。 #  解释：\n查看环境对语言特性的支持程度\nES 标准的制定还在不断进行中，各种环境对语言特性的支持也日新月异。了解项目中用到了哪些 ESNext 的特性，了解项目的运行环境，并持续跟进这些特性在运行环境中的支持程度是很有必要的。这意味着：\n 如果有任何一个运行环境（比如 chrome）支持了项目里用到的所有特性，你可以在开发时抛弃预编译。 如果所有环境都支持了某一特性（比如 Promise），你可以抛弃相关的 shim，或无需在预编译时进行转换。 如果所有环境都支持了项目里用到的所有特性，你可以完全抛弃预编译。  无论如何，在选择预编译工具时，你都需要清晰的知道你现阶段将在项目里使用哪些语言特性，然后了解预编译工具对语言特性的支持程度，做出选择。\n[强制] 在运行环境中没有 Promise 时，将 Promise 的实现 shim 到 global 中。 #  解释：\n当前运行环境下没有 Promise 时，可以引入 shim 的扩展。如果自己实现，需要实现在 global 下，并且与标准 API 保持一致。\n这样，未来运行环境支持时，可以随时把 Promise 扩展直接扔掉，而应用代码无需任何修改。\n4.2 预编译 #  [建议] 使用 babel 做为预编译工具时，建议使用 5.x 版本。 #  解释：\n由于 babel 最新的 6 暂时还不稳定，建议暂时使用 5.x。不同的产品，对于浏览器支持的情况不同，使用 babel 的时候，需要设置的参数也有一些区别。下面在示例中给出一些建议的参数。\n示例：\n＃ 建议的参数 --loose all --modules amd --blacklist strict ＃ 如果需要使用 es7.classProperties、es7.decorators 等一些特性，需要额外的 --stage 0 参数 --loose all --modules amd --blacklist strict --stage 0 [建议] 使用 babel 做为预编译工具时，通过 external-helpers 减少生成文件的大小。 #  解释：\n当 babel 在转换代码的过程中发现需要一些特性时，会在该文件头部生成对应的 helper 代码。默认情况下，对于每一个经由 babel 处理的文件，均会在文件头部生成对应需要的辅助函数，多份文件辅助函数存在重复，占用了不必要的代码体积。\n因此推荐打开externalHelpers: true选项，使 babel 在转换后内容中不写入 helper 相关的代码，而是使用一个外部的 .js统一提供所有的 helper。对于external-helpers的使用，可以有两种方式：\n 默认方式：需要通过 \u0026lt;script\u0026gt; 自行引入babel-polyfill.js 和 babel-external-helpers.js。 定制方式：自己实现 babel-runtime。  示例：\n# 默认方式 --loose all --modules amd --external-helpers # `babelHelpers` 的代码可以通过执行 `babel-external-helpers -t var` 得到所有相关API的实现 # 定制方式 --loose all --modules amd --optional runtime [建议] 使用 TypeScript 做为预编译工具时，建议使用 1.6+ 版本。 #  解释：\nTypeScript 1.6 之后，基本摒弃了之前的与 ESNext 相冲突的地方。目前 TypeScript 的思路就是遵循标准，将 stage 已经足够成熟的功能纳入，并提供静态类型和类型检查，所以其在 stage 0/1 的支持上不如 babel。另外，TypeScript 不能指定关闭某个 transform，但其编译速度比 babel 更高。\nTypeScript 的常用参数在下面给出了示例。\n示例：\n--module amd --target ES3 --module commonjs --target ES6 [建议] 使用 TypeScript 做为预编译工具时，不使用 tsc 命令。 #  解释：\nTypeScript 提供的 tsc 命令只支持后缀名 .ts、.tsx、.d.ts 的文件编译，对于 JavaScript 来说，保持后缀名为 .js 是原则，本文档的 文件 章节也有所要求。\n如果要使用 TypeScript 做为预编译工具，可基于其 Compiler API 开发自己的预编译工具。如果你是 FIS 用户，可以使用 FIS TypeScript 插件。\n[建议] 生成的代码在浏览器环境运行时，应生成 AMD 模块化代码。 #  解释：\nAMD 在浏览器环境应用较为成熟。\n[建议] 浏览器端项目中如果 ESNext 代码和 ES3/5 代码混合，不要使用 TypeScript 做为预编译工具。 #  解释：\nTypeScript 产生的 module 代码使用 exports.default 导出默认的 export，但是没有直接为 module.exports 赋值，导致在另外一个普通文件中使用 require(\u0026lsquo;moduleName\u0026rsquo;) 是拿不到东西的。\n需要使用 TypeScript 的话，建议整个项目所有文件都是 ESNext module 的，采用混合的 module 容易出现不可预期的结果。\n[建议] AMD/CommonJS 模块依赖 ESNext 模块时，AMD/CommonJS 模块对 default export 的 require 需要改造。 #  解释：\nESNext 模块经过编译后，named export 会挂载在 exports 对象上，default export 也会挂载在 exports 对象上名称为 default 的属性。同时 exports 对象会包含一个值为 true 的 __esModule 属性。那么问题来了，当 AMD/CommonJS 模块依赖了 ESNext 模块时，require 期望拿到的是 exports.default，但你实际上拿到的是 exports。\n所以，老的 AMD/CommonJS 模块依赖了 default export 的 ESNext 模块时，对 default export 的 require 需要改造成 require('name').default。\n另外，如果是 ESNext 模块之间的互相依赖，transpiler 会通过加入中间对象和引入 interop 方法，所以不会产生这个问题。\n"}),a.add({id:13,href:'/study-javascript/docs/basic/practice/spec/baidu/html/',title:"HTML",section:"百度前端编程规范",content:"HTML 编码规范 #  1 前言\n2 代码风格\n2.1 缩进与换行\n2.2 命名\n2.3 标签\n2.4 属性\n3 通用\n3.1 DOCTYPE\n3.2 编码\n3.3 CSS 和 JavaScript 引入\n4 head\n4.1 title\n4.2 favicon\n4.3 viewport\n5 图片\n6 表单\n6.1 控件标题\n6.2 按钮\n6.3 可访问性 (A11Y)\n7 多媒体\n8 模板中的 HTML\n1 前言 #  HTML 作为描述网页结构的超文本标记语言，在百度一直有着广泛的应用。本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 缩进与换行 #  [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。 #  解释： 对于非 HTML 标签之间的缩进，比如 script 或 style 标签内容缩进，与 script 或 style 标签的缩进同级。\n示例：\n\u0026lt;style\u0026gt; /* 样式内容的第一级缩进与所属的 style 标签对齐 */ ul { padding: 0; } \u0026lt;/style\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; // 脚本代码的第一级缩进与所属的 script 标签对齐  require([\u0026#34;app\u0026#34;], function (app) { app.init(); }); \u0026lt;/script\u0026gt; [建议] 每行不得超过 120 个字符。 #  解释：\n过长的代码不容易阅读与维护。但是考虑到 HTML 的特殊性，不做硬性要求。\n2.2 命名 #  [强制] class 必须单词全字母小写，单词间以 - 分隔。 #  [强制] class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [强制] 元素 id 必须保证页面唯一。 #  解释：\n同一个页面中，不同的元素包含相同的 id，不符合 id 的属性含义。并且使用 document.getElementById 时可能导致难以追查的问题。\n[建议] id 建议单词全字母小写，单词间以 - 分隔。同项目必须保持风格一致。 #  [建议] id、class 命名，在避免冲突并描述清楚的前提下尽可能短。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;div id=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div id=\u0026#34;navigation\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- good --\u0026gt; \u0026lt;p class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;p class=\u0026#34;com\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- good --\u0026gt; \u0026lt;span class=\u0026#34;author\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;span class=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; [强制] 禁止为了 hook 脚本，创建无样式信息的 class。 #  解释：\n不允许 class 只用于让 JavaScript 选择某些元素，class 应该具有明确的语义和样式。否则容易导致 CSS class 泛滥。\n使用 id、属性选择作为 hook 是更好的方式。\n[强制] 同一页面，应避免使用相同的 name 与 id。 #  解释：\nIE 浏览器会混淆元素的 id 和 name 属性， document.getElementById 可能获得不期望的元素。所以在对元素的 id 与 name 属性的命名需要非常小心。\n一个比较好的实践是，为 id 和 name 使用不同的命名法。\n示例：\n\u0026lt;input name=\u0026#34;foo\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // IE6 将显示 INPUT  alert(document.getElementById(\u0026#34;foo\u0026#34;).tagName); \u0026lt;/script\u0026gt; 2.3 标签 #  [强制] 标签名必须使用小写字母。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;p\u0026gt;Hello StyleGuide!\u0026lt;/p\u0026gt; [强制] 对于无需自闭合的标签，不允许自闭合。 #  解释：\n常见无需自闭合标签有 input、br、img、hr 等。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; /\u0026gt; [强制] 对 HTML5 中规定允许省略的闭合标签，不允许省略闭合标签。 #  解释：\n对代码体积要求非常严苛的场景，可以例外。比如：第三方页面使用的投放系统。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; [强制] 标签使用必须符合标签嵌套规则。 #  解释：\n比如 div 不得置于 p 中，tbody 必须置于 table 中。\n详细的标签嵌套规则参见HTML DTD中的 Elements 定义部分。\n[建议] HTML 标签的使用应该遵循标签的语义。 #  解释：\n下面是常见标签语义\n p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;p\u0026gt; Esprima serves as an important \u0026lt;strong\u0026gt;building block\u0026lt;/strong\u0026gt; for some JavaScript language tools. \u0026lt;/p\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;div\u0026gt; Esprima serves as an important \u0026lt;span class=\u0026#34;strong\u0026#34;\u0026gt;building block\u0026lt;/span\u0026gt; for some JavaScript language tools. \u0026lt;/div\u0026gt; [建议] 在 CSS 可以实现相同需求的情况下不得使用表格进行布局。 #  解释：\n在兼容性允许的情况下应尽量保持语义正确性。对网格对齐和拉伸性有严格要求的场景允许例外，如多列复杂表单。\n[建议] 标签的使用应尽量简洁，减少不必要的标签。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;img class=\u0026#34;avatar\u0026#34; src=\u0026#34;image.png\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;span class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;image.png\u0026#34; /\u0026gt; \u0026lt;/span\u0026gt; 2.4 属性 #  [强制] 属性名必须使用小写字母。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt; ... \u0026lt;/table\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;table cellspacing=\u0026#34;0\u0026#34;\u0026gt; ... \u0026lt;/table\u0026gt; [强制] 属性值必须用双引号包围。 #  解释：\n不允许使用单引号，不允许不使用引号。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;esl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; [强制] 属性名与属性值中间不得存在空格。 #  解释：\n按 HTML 规范 = 两边可以存在空格，但为了保持一致不允许添加空格。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; [建议] 布尔类型的属性，建议不添加属性值。 #  示例：\n\u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;1\u0026#34; checked /\u0026gt; [建议] 自定义属性建议以 xxx- 为前缀，推荐使用 data-。 #  解释：\n使用前缀有助于区分自定义属性和标准定义的属性。\n示例：\n\u0026lt;ol data-ui-type=\u0026#34;Select\u0026#34;\u0026gt;\u0026lt;/ol\u0026gt; 3 通用 #  3.1 DOCTYPE #  [强制] 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。 #  示例：\n\u0026lt;!DOCTYPE html\u0026gt; [建议] 启用 IE Edge 模式。 #  示例：\n\u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=Edge\u0026#34; /\u0026gt; [建议] 在 html 标签上设置正确的 lang 属性。 #  解释：\n有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。\n示例：\n\u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt;\u0026lt;/html\u0026gt; 3.2 编码 #  [强制] 页面必须使用精简形式，明确指定字符编码。指定字符编码的 meta 必须是 head 的第一个直接子元素。 #  解释：\n见 HTML5 Charset 能用吗 一文。\n示例：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; ...... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ...... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [建议] HTML 文件使用无 BOM 的 UTF-8 编码。 #  解释：\nUTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。\n3.3 CSS 和 JavaScript 引入 #  [强制] 引入 CSS 时必须指明 rel=\u0026quot;stylesheet\u0026quot;。 #  示例：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;page.css\u0026#34; /\u0026gt; [建议] 引入 CSS 和 JavaScript 时无须指明 type 属性。 #  解释：\ntext/css 和 text/javascript 是 type 的默认值。\n[建议] 展现定义放置于外部 CSS 中，行为定义放置于外部 JavaScript 中。 #  解释：\n结构-样式-行为的代码分离，对于提高代码的可阅读性和维护性都有好处。\n[建议] 在 head 中引入页面需要的所有 CSS 资源。 #  解释：\n在页面渲染的过程中，新的 CSS 可能导致元素的样式重新计算和绘制，页面闪烁。\n[建议] JavaScript 应当放在页面末尾，或采用异步加载。 #  解释：\n将 script 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。\n示例：\n\u0026lt;body\u0026gt; \u0026lt;!-- a lot of elements --\u0026gt; \u0026lt;script src=\u0026#34;init-behavior.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; [建议] 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。 #  解释：\n使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境。\n示例：\n\u0026lt;script src=\u0026#34;//s1.bdstatic.com/cache/static/jquery-1.10.2.min_f2fb5194.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4 head #  4.1 title #  [强制] 页面必须包含 title 标签声明标题。 #  [强制] title 必须作为 head 的直接子元素，并紧随 charset 声明之后。 #  解释：\ntitle 中如果包含 ASCII 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。\n示例：\n\u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;页面标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; 4.2 favicon #  [强制] 保证 favicon 可访问。 #  解释：\n在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免 404，必须遵循以下两种方法之一：\n 在 Web Server 根目录放置 favicon.ico 文件。 使用 link 指定 favicon。  示例：\n\u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;path/to/favicon.ico\u0026#34; /\u0026gt; 4.3 viewport #  [建议] 若页面欲对移动设备友好，需指定页面的 viewport。 #  解释：\nviewport meta tag 可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。\n比如，在页面宽度小于 980px 时，若需 iOS 设备友好，应当设置 viewport 的 width 值来适应你的页面宽度。同时因为不同移动设备分辨率不同，在设置时，应当使用 device-width 和 device-height 变量。\n另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，可以参见 Safari Web Content Guide 的介绍\n5 图片 #  [强制] 禁止 img 的 src 取值为空。延迟加载的图片也要增加默认的 src。 #  解释：\nsrc 取值为空，会导致部分浏览器重新加载一次当前页面，参考：https://developer.yahoo.com/performance/rules.html#emptysrc\n[建议] 避免为 img 添加不必要的 title 属性。 #  解释：\n多余的 title 影响看图体验，并且增加了页面尺寸。\n[建议] 为重要图片添加 alt 属性。 #  解释：\n可以提高图片加载失败时的用户体验。\n[建议] 添加 width 和 height 属性，以避免页面抖动。 #  [建议] 有下载需求的图片采用 img 标签实现，无下载需求的图片采用 CSS 背景图实现。 #  解释：\n 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。  6 表单 #  6.1 控件标题 #  [强制] 有文本标题的控件必须使用 label 标签将其与其标题相关联。 #  解释：\n有两种方式：\n 将控件置于 label 内。 label 的 for 属性指向控件的 id。  推荐使用第一种，减少不必要的 id。如果 DOM 结构不允许直接嵌套，则应使用第二种。\n示例：\n\u0026lt;label \u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;confirm\u0026#34; value=\u0026#34;on\u0026#34; /\u0026gt; 我已确认上述条款\u0026lt;/label \u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;textbox\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;username\u0026#34; /\u0026gt; 6.2 按钮 #  [强制] 使用 button 元素时必须指明 type 属性值。 #  解释：\nbutton 元素的默认 type 为 submit，如果被置于 form 元素中，点击后将导致表单提交。为显示区分其作用方便理解，必须给出 type 属性。\n示例：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; [建议] 尽量不要使用按钮类元素的 name 属性。 #  解释：\n由于浏览器兼容性问题，使用按钮的 name 属性会带来许多难以发现的问题。具体情况可参考此文。\n6.3 可访问性 (A11Y) #  [建议] 负责主要功能的按钮在 DOM 中的顺序应靠前。 #  解释：\n负责主要功能的按钮应相对靠前，以提高可访问性。如果在 CSS 中指定了 float: right 则可能导致视觉上主按钮在前，而 DOM 中主按钮靠后的情况。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;style\u0026gt; .buttons .button-group { float: right; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;button-group\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;style\u0026gt; .buttons button { float: right; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; [建议] 当使用 JavaScript 进行表单提交时，如果条件允许，应使原生提交功能正常工作。 #  解释：\n当浏览器 JS 运行错误或关闭 JS 时，提交功能将无法工作。如果正确指定了 form 元素的 action 属性和表单控件的 name 属性时，提交仍可继续进行。\n示例：\n\u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; [建议] 在针对移动设备开发的页面时，根据内容类型指定输入框的 type 属性。 #  解释：\n根据内容类型指定输入框类型，能获得能友好的输入体验。\n示例：\n\u0026lt;input type=\u0026#34;date\u0026#34; /\u0026gt; 7 多媒体 #  [建议] 当在现代浏览器中使用 audio 以及 video 标签来播放音频、视频时，应当注意格式。 #  解释：\n音频应尽可能覆盖到如下格式：\n MP3 WAV Ogg  视频应尽可能覆盖到如下格式：\n MP4 WebM Ogg  [建议] 在支持 HTML5 的浏览器中优先使用 audio 和 video 标签来定义音视频元素。 #  [建议] 使用退化到插件的方式来对多浏览器进行支持。 #  示例：\n\u0026lt;audio controls\u0026gt; \u0026lt;source src=\u0026#34;audio.mp3\u0026#34; type=\u0026#34;audio/mpeg\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;audio.ogg\u0026#34; type=\u0026#34;audio/ogg\u0026#34; /\u0026gt; \u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;audio.mp3\u0026#34;\u0026gt; \u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;audio.swf\u0026#34; /\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/audio\u0026gt; \u0026lt;video width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; controls\u0026gt; \u0026lt;source src=\u0026#34;video.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;video.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34; /\u0026gt; \u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;video.mp4\u0026#34;\u0026gt; \u0026lt;embed width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; src=\u0026#34;video.swf\u0026#34; /\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/video\u0026gt; [建议] 只在必要的时候开启音视频的自动播放。 #  [建议] 在 object 标签内部提供指示浏览器不支持该标签的说明。 #  示例：\n\u0026lt;object width=\u0026#34;100\u0026#34; height=\u0026#34;50\u0026#34; data=\u0026#34;something.swf\u0026#34; \u0026gt;DO NOT SUPPORT THIS TAG\u0026lt;/object \u0026gt; 8 模板中的 HTML #  [建议] 模板代码的缩进优先保证 HTML 代码的缩进规则。 #  示例：\n\u0026lt;!-- good --\u0026gt; {if $display == true} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {foreach $item_list as $item} \u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; {/foreach} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/if} \u0026lt;!-- bad --\u0026gt; {if $display == true} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {foreach $item_list as $item} \u0026lt;li\u0026gt;{$item.name}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; {/foreach} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {/if} [建议] 模板代码应以保证 HTML 单个标签语法的正确性为基本原则。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;li class=\u0026#34;{if $item.type_id == $current_type}focus{/if}\u0026#34;\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;li {if $item.type_id == $current_type} class=\u0026#34;focus\u0026#34;{/if}\u0026gt;{ $item.type_name }\u0026lt;/li\u0026gt; [建议] 在循环处理模板数据构造表格时，若要求每行输出固定的个数，建议先将数据分组，之后再循环输出。 #  示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;table\u0026gt; {foreach $item_list as $item_group} \u0026lt;tr\u0026gt; {foreach $item_group as $item} \u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt; {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; {foreach $item_list as $item} \u0026lt;td\u0026gt;{ $item.name }\u0026lt;/td\u0026gt; {if $item@iteration is div by 5} \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; {/if} {/foreach} \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; [建议] 新窗口/标签页打开的链接需要按业务需要添加安全相关的 rel 属性值 noopener。 #  解释：\n新窗口/标签页打开的网页可以通过 window.opener 访问原网页的上下文，会引入安全问题。例如从搜索结果页打开的网页可以通过 window.opener 将结果页篡改为钓鱼网页，用户返回时将访问恶意网页内容。详见 4.8.6.8. Link type \u0026ldquo;noopener\u0026rdquo; - HTML 5.2。\n示例：\n\u0026lt;!-- good --\u0026gt; \u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt; \u0026lt;!-- bad --\u0026gt; \u0026lt;a href=\u0026#34;//external.website/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;外部链接\u0026lt;/a\u0026gt; "}),a.add({id:14,href:'/study-javascript/docs/basic/practice/spec/baidu/react/',title:"React",section:"百度前端编程规范",content:"React 编码规范 #  1 版本限制\n1.1 法律要求\n2 文件组织\n2.1 命名\n2.2 模块化\n3 命名规则\n3.1 组件\n3.2 属性\n3.3 高阶组件\n4 组件声明\n4.1 组件\n4.2 属性\n4.3 生命周期\n4.4 高阶组件\n5 组件实现\n5.1 更新机制\n5.2 纯函数应用\n6 JSX\n6.1 标签\n6.2 属性\n6.2.1 层级\n1 版本限制 #  1.1 法律要求 #  [强制] 使用 React \u0026gt;=15.6.2版本 #  解释\n在15.6.2以前的版本协议带有 Facebook Patents，依据法务风险，严禁使用。\n2 文件组织 #  2.1 命名 #  [强制] 同一目录下不得拥有同名的.js和.jsx文件。 #  解释：\n在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。\n[强制] 组件文件使用一致的.js或 .jsx后缀。 #  解释：\n所有组件文件的后缀名从.js或.jsx中任选其一。\n不应在项目中出现部分组件为.js文件，部分为.jsx的情况。\n2.2 模块化 #  [建议] 实现单个组件的文件以export default的形式暴露一个组件。 #  解释：\n允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其它组件均定义为内部组件。\n[建议] 组织多个组件的目录使用一个index.js以命名导出的形式暴露所有组件。 #  解释：\n同目录内的组件相互引用使用import Foo from './Foo';进行。\n引用其它目录的组件使用import {Foo} from '../component';进行。\n建议使用VSCode 的 export-index 插件等插件自动生成index.js的内容。\n3 命名规则 #  3.1 组件 #  [强制] 组件名为 PascalCase。 #  包括函数组件，名称均为 PascalCase。\n[强制] 组件名称与文件名称保持相同。 #  同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。\n3.2 属性 #  [强制] 使用onXxx形式作为props中用于回调的属性名称。 #  解释：\n使用统一的命名规则用以区分props中回调和非回调部分的属性，在 JSX 上可以清晰地看到一个组件向上和向下的逻辑交互。\n对于不用于回调的函数类型的属性，使用动词作为属性名称。\n示例：\n// onClick作为回调以on开头，renderText非回调函数则使用动词 let Label = ({ onClick, renderText }) =\u0026gt; ( \u0026lt;span onClick={onClick}\u0026gt;{renderText()}\u0026lt;/span\u0026gt; ); [建议] 作为组件方法的事件处理函数以具备业务含义的词作为名称，不使用onXxx形式命名。 #  示例：\n// Good class Form { @bind() collectAndSubmitData() { let data = { name: this.state.name, age: this.state.age }; this.props.onSubmit(data); } @bind() syncName() { // ...  } @bind() syncAge() { // ...  } render() { return ( \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; 姓名： \u0026lt;input type=\u0026#34;text\u0026#34; onChange={this.syncName} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt; 年龄： \u0026lt;input type=\u0026#34;number\u0026#34; onChange={this.syncAge} /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.collectAndSubmit}\u0026gt; 提交 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } } 3.3 高阶组件 #  [强制] 高阶组件使用 camelCase 命名。 #  解释：\n高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守 JavaScript 函数命名的规范，使用 camelCase 命名。\n[建议] 使用withXxx或xxxable形式的词作为高阶组件的名称。 #  解释：\n高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。\n4 组件声明 #  4.1 组件 #  [强制] 使用 ES Class 声明组件，禁止使用React.createClass。 #  解释：\nReact v15.5.0已经弃用了React.createClass函数。\n示例：\n// Bad let Message = React.createClass({ render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } }); // Good class Message extends PureComponent { render() { return \u0026lt;span\u0026gt;{this.state.message}\u0026lt;/span\u0026gt;; } } [强制] 尽量使用无状态函数组件。 #  解释：\n函数组件在 React 中有着特殊的地位，在将来也有可能得到更多的内部优化。\n示例：\n// Bad class NextNumber { render() { return \u0026lt;span\u0026gt;{this.props.value + 1}\u0026lt;/span\u0026gt;; } } // Good let NextNumber = ({ value }) =\u0026gt; \u0026lt;span\u0026gt;{value + 1}\u0026lt;/span\u0026gt;; [建议] 无需显式引入 React 对象。 #  解释：\n使用 JSX 隐式地依赖当前环境下有React这一对象，但在源码上并没有显式使用，这种情况下添加import React from 'react';会造成一个没有使用的变量存在。\n使用babel-plugin-react-require插件可以很好地解决这一问题，因此无需显式地编写import React from 'react';这一语句。\n[建议] 使用箭头函数声明函数组件。 #  解释：\n箭头函数具备更简洁的语法（无需function关键字），且可以在仅有一个语句时省去return造成的额外缩进。\n4.2 属性 #  [强制] 对于所有非isRequired的属性，在defaultProps中声明对应的值。 #  解释：\n声明初始值有助于对组件初始状态的理解，也可以减少propTypes对类型进行校验产生的开销。\n对于初始没有值的属性，应当声明初始值为null而非undefined。\n[强制] 如无必要，使用属性语法声明propsTypes、contextTypes、defaultProps和state。 #  解释：\n仅当初始state需要从props计算得到的时候，才将state的声明放在构造函数中，其它情况下均使用属性声明进行。\n4.3 生命周期 #  [强制] 禁止使用componentWillMount。 #  解释：\n使用constructor代替。\n[强制] 依照规定顺序编排组件中的方法和属性。 #  按照以下顺序编排组件中的方法和属性：\n static displayName static propTypes state defaultProps 其它静态的属性 state 其它实例属性 用于事件处理并且以属性的方式（onClick = e =\u0026gt; {...}）声明的方法 constructor componentDidMount shouldComponentUpdate static getDerivedStateFromProps componentDidUpdate componentWillUnmount 事件处理方法 其它方法 render  4.4 高阶组件 #  [建议] 高阶组件返回新的组件类型时，添加displayName属性。 #  同时在displayName上声明高阶组件的存在。\n// Good let asPureComponent = Component =\u0026gt; { let componentName = Component.displayName || Component.name || \u0026#39;UnknownComponent\u0026#39;; return class extends PureComponent { static displayName = `asPure(${componentName})` render() { return \u0026lt;Component {..this.props} /\u0026gt;; } }; }; 5 组件实现 #  5.1 更新机制 #  [强制] 禁止为继承自PureComponent的组件编写shouldComponentUpdate实现。 #  参考React 的相关 Issue，在 React 的实现中，PureComponent并不直接实现shouldComponentUpdate，而是添加一个isReactPureComponent的标记，由CompositeComponent通过识别这个标记实现相关的逻辑。因此在PureComponent上自定义shouldComponentUpdate并无法享受super.shouldComponentUpdate的逻辑复用，也会使得这个继承关系失去意义。\n5.2 纯函数应用 #  [强制] 禁止在componentWillReceiveProps中包含除setState外的副作用。 #  解释：\ncomponentWillReceiveProps应当且仅应当用于props和state的数据同步，不得用于获取远程数据、更新外部状态、执行回调函数等逻辑。\n新版 React 使用getDerivedStateFromProps代替componentWillReceiveProps。\n[建议] 除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。 #  本条规则并非要求组件继承自PureComponent，“概念上的纯组件”的意思为一个组件在props和state没有变化（shallowEqual）的情况下，渲染的结果应保持一致。\n一个典型的非纯组件是使用了随机数或日期等函数：\nlet RandomNumber = () =\u0026gt; \u0026lt;span\u0026gt;{Math.random()}\u0026lt;/span\u0026gt;; let Clock = () =\u0026gt; \u0026lt;span\u0026gt;{Date.time()}\u0026lt;/span\u0026gt;; 非纯组件具备向上的“传染性”，即一个包含非纯组件的组件也必须是非纯组件，依次沿组件树结构向上。由于非纯组件无法通过shouldComponentUpdate优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。\n如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过props传递下来。对于使用 Redux 等应用状态管理的系统，可以在应用状态中存放相关值（如 Redux 使用 Action Creator 生成这些值并通过 Action 和 reducer 更新到 store 中）。\n6 JSX #  6.1 标签 #  [强制] 没有子节点的组件使用自闭合语法。 #  解释：\nJSX 与 HTML 不同，所有元素均可以自闭合。\n示例：\n// Bad \u0026lt;Foo\u0026gt;\u0026lt;/Foo\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; // Good \u0026lt;Foo /\u0026gt; \u0026lt;div /\u0026gt; [强制] 保持起始和结束标签在同一层缩进。 #  解释：\n对于标签前面有其它语句（如return的情况，使用括号进行换行和缩进）。\n对于直接return的函数组件，可以直接使用括号而省去大括号和return关键字：\nlet Message = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); 示例：\n// Bad class Message { render() { return \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; } } // Good class Message { render() { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Hello World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt;; ); } } [强制] 自闭合标签的/\u0026gt;前添加一个空格。 #  示例：\n// Bad \u0026lt;Foo bar=\u0026#34;bar\u0026#34;/\u0026gt; \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; 6.2 属性 #  [强制] 对于多属性需要换行，从第一个属性开始，每个属性一行。 #  示例：\n// 没有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} /\u0026gt; // 有子节点 \u0026lt;SomeComponent longProp={longProp} anotherLongProp={anotherLongProp} \u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;SomeChild /\u0026gt; \u0026lt;/SomeComponent\u0026gt; [强制] 以字符串字面量作为值的属性使用双引号（\u0026quot;），在其它类型表达式中的字符串使用单引号（'）。 #  示例：\n// Bad \u0026lt;Foo bar=\u0026#39;bar\u0026#39; /\u0026gt; \u0026lt;Foo style={{width: \u0026#34;20px\u0026#34;}} /\u0026gt; // Good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; \u0026lt;Foo style={{width: \u0026#39;20px\u0026#39;}} /\u0026gt; [强制] 对于值为true的属性，省去值部分。 #  示例：\n// Bad \u0026lt;Foo visible={true} /\u0026gt; // Good \u0026lt;Foo visible /\u0026gt; [强制] 值为true的属性放在其它属性前面。 #  解释：\n将true类的值放在前面使得组件的声明更接近自然语言，提高可读性。\n示例：\n// Bad \u0026lt;Foo data={data} visible requireValidation /\u0026gt; // Good \u0026lt;Foo visible requireValidation data={data} /\u0026gt; [强制] 对于需要使用key的场合，提供一个唯一标识作为key属性的值，禁止使用可能会变化的属性（如索引）。 #  解释：\nkey属性是 React 在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和正确性都无法得到保证。\n示例：\n// Bad { list.map((item, index) =\u0026gt; \u0026lt;Foo key={index} {...item} /\u0026gt;); } // Good { list.map(item =\u0026gt; \u0026lt;Foo key={item.id} {...item} /\u0026gt;); } [建议] 避免在 JSX 的属性值中直接使用对象和函数表达式。 #  解释：\nPureComponent使用shallowEqual对props和state进行比较来决定是否需要渲染，而在 JSX 的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而shallowEqual会返回false，导致不必要的渲染。\n示例：\n// Bad class WarnButton { alertMessage(message) { alert(message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={() =\u0026gt; this.alertMessage(this.props.message)} \u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } // Good class WarnButton { @bind() alertMessage() { alert(this.props.message); } render() { return ( \u0026lt;button type=\u0026#34;button\u0026#34; onClick={this.alertMessage}\u0026gt; 提示 \u0026lt;/button\u0026gt; ); } } 6.2.1 层级 #  [建议] 将 JSX 的层级控制在 5 层以内。 #  解释：\nJSX 提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对 JSX 的层级进行控制可以有效提升代码的可维护性。\n示例：\n// Bad let List = ({ items }) =\u0026gt; ( \u0026lt;ul\u0026gt; {items.map(item =\u0026gt; ( \u0026lt;li\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{item.title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{item.subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt;{item.content}\u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{item.author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{item.postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); // Good let Header = ({ title, subtitle }) =\u0026gt; ( \u0026lt;header\u0026gt; \u0026lt;h3\u0026gt;{title}\u0026lt;/h3\u0026gt; \u0026lt;span\u0026gt;{subtitle}\u0026lt;/span\u0026gt; \u0026lt;/header\u0026gt; ); let Content = ({ content }) =\u0026gt; \u0026lt;section\u0026gt;{content}\u0026lt;/section\u0026gt;; let Footer = ({ author, postTime }) =\u0026gt; ( \u0026lt;footer\u0026gt; \u0026lt;span\u0026gt;{author}\u0026lt;/span\u0026gt;@\u0026lt;time\u0026gt;{postTime}\u0026lt;/time\u0026gt; \u0026lt;/footer\u0026gt; ); let Item = item =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header {...item} /\u0026gt; \u0026lt;Content {...item} /\u0026gt; \u0026lt;Footer {...item} /\u0026gt; \u0026lt;/div\u0026gt; ); let List = ({ items }) =\u0026gt; \u0026lt;ul\u0026gt;{items.map(Item)}\u0026lt;/ul\u0026gt;; "}),a.add({id:15,href:'/study-javascript/docs/basic/practice/spec/baidu/typescript/',title:"Typescript",section:"百度前端编程规范",content:"TypeScript 编码规范 #  1 前言\n2 代码风格\n2.1 环境\n2.2 文件\n2.3 命名\n3 语言特性\n3.1 变量\n3.2 类型\n3.3 条件\n3.4 循环\n3.5 数组\n3.6 对象\n3.7 函数\n3.8 类\n3.9 模块\n1 前言 #  随着 TypeScript 的不断发展，越来越多的开发者认可并使用 TypeScript 开发应用。本文档的目标是使 TypeScript 新特性的代码风格保持一致，并给予一些实践建议。\n本文档基本遵循 JavaScript Style Guide 与 \u0010ES-Next Style Guide。\n由于 TypeScript 依然在快速发展，本文档也将随时保持更新。更新内容主要涉及对新增的语言特性的格式规范化、实践指导，引擎与编译器环境变化的使用指导。\n任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 环境 #  [强制] TypeScript 文件使用 .ts 扩展名。含 JSX 语法的 TypeScript 文件使用 .tsx 扩展名。 #  [建议] tsconfig.json 配置文件应开启 strict、noImplicitReturns、noUnusedLocals 选项。 #  [建议] tsconfig.json 配置文件应开启 allowSyntheticDefaultImports 选项。 #  示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import * as React from \u0026#34;react\u0026#34;; [建议] 使用 VS Code 编写 TypeScript。 #  2.2 文件 #  [强制] 在文件结尾处，保留一个空行。 #  2.3 命名 #  [强制] 接口 使用 Pascal 命名法。 #  [强制] 接口名 不使用 I 作为前缀。 #  示例：\n// good interface ButtonProps { // ... } // bad interface IButtonProps { // ... } [强制] 类型别名 使用 Pascal 命名法。 #  示例：\n// good interface HeaderStateProps { // ... } interface HeaderDispatchProps { // ... } type HeaderProps = HeaderStateProps \u0026amp; HeaderDispatchProps; 3 语言特性 #  3.1 变量 #  [强制] 使用 const 声明 枚举 。 #  示例：\n// good const enum Directions { UP, DOWM, LEFT, RIGHT } // bad enum Directions { UP, DOWN, LEFT, RIGHT } 3.2 类型 #  [强制] 不应显式声明可以自动推导的类型。 #  示例：\n// good let shouldUpdate = false; // bad let shouldUpdate: boolean = false; [强制] 使用 string / number / boolean 声明基本类型，不使用 String / Number / Boolean。 #  示例：\n// good let str: string; // bad let str: String; [强制] 不使用 Object / Function 声明类型。 #  [强制] 数组元素为简单类型（非匿名且不含泛型）时，使用 T[] 声明类型，否则应使用 Array\u0026lt;T\u0026gt;。 #  [建议] 数组元素为不可变数据时，使用 ReadonlyArray\u0026lt;T\u0026gt; 声明类型。 #  示例：\n// good let files: string[]; let tokens: Array\u0026lt;string | number\u0026gt;; let buffer: Buffer[]; let responses: Array\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; // bad let files: Array\u0026lt;string\u0026gt;; let tokens: (string | number)[]; let buffer: Array\u0026lt;Buffer\u0026gt;; let responses: Promise\u0026lt;number\u0026gt;[]; [强制] 不使用 ! 声明对象属性非空。 #  示例：\n// good if (foo.bar \u0026amp;\u0026amp; foo.bar.baz) { // ... } // bad if (foo!.bar!.baz) { // ... } [建议] 不使用 any 声明类型。 #  示例：\n// good const identity = \u0026lt;T\u0026gt;(x: T) =\u0026gt; x; // bad const identity = (x: any) =\u0026gt; x; [强制] 使用 as 进行类型声明转换，不使用 \u0026lt;\u0026gt; 。 #  示例：\n// good const root = document.getElementById(\u0026#34;root\u0026#34;) as HTMLDivElement; // bad const root = \u0026lt;HTMLDivElement\u0026gt;document.getElementById(\u0026#34;root\u0026#34;); [强制] 接口不应为空。 #  [强制] 接口中同一函数重载的类型声明需相邻。 #  示例：\n// good interface AnyInterface { foo(); foo(x: string); bar(); bar(x: number); } // bad interface AnyInterface { foo(); bar(); foo(x: string); bar(x: number); } 3.3 条件 #  [强制] 使用 === 或 !== 判断相等性，不使用 == 或 !=。 #  示例：\n// good if (foo !== null \u0026amp;\u0026amp; foo !== undefined) { // ... } // bad if (foo != null) { // ... } 3.4 循环 #  [建议] 使用 Object.keys / Object.values / Object.entries / Object.getOwnPropertyNames 遍历对象，不使用 for .. in 。 #  示例：\n// good Object.keys(obj).forEach(key =\u0026gt; /* ... */); // bad for (const key in obj) { if (obj.hasOwnProperty(key)) { // ...  } } [建议] 索引仅用于获取数组当前被迭代的项时，使用 for .. of 遍历数组，不使用 for 。 #  示例：\n// good for (const item of items) { // ... } // bad for (let i = 0; i \u0026lt; items.length; i++) { const item = items[i]; // ... } 3.5 数组 #  [建议] 使用 ... 进行数组浅拷贝，不使用 Array.from / Array.prototype.slice 。 #  示例：\n// good const copies = [...items]; // bad const copies = items.slice(); // worst let copies = []; for (let i = 0; i \u0026lt; items.length; i++) { copies.push(items[i]); } [建议] 使用 ... 将类数组对象转化为数组，不使用 Array.from / Array.prototype.slice 。 #  示例：\n// good const elements = [...document.querySelectorAll(\u0026#34;.foo\u0026#34;)]; // bad const element = Array.from(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); // worst const element = Array.prototype.slice.call(document.querySelectorAll(\u0026#34;.foo\u0026#34;)); 3.6 对象 #  [强制] 使用 ... 进行对象浅拷贝，不使用 Object.assign 。 #  示例：\n// good this.setState(state =\u0026gt; ({ ...state, clicked: true })); // bad this.setState(state =\u0026gt; Object.assign({}, state, { clicked: true })); 3.7 函数 #  [强制] 避免 return undefined ，应直接 return。 #  示例：\n// good function foo(bar: boolean) { if (!bar) { return; } } // bad function foo(bar: boolean) { if (!bar) { return undefined; } } 3.8 类 #  [建议] 每个文件中最多声明一个类。 #  [强制] 类成员的可访问性为 public 时，不应显式声明。 #  [建议] 构造函数可忽略时，应忽略。 #  [建议] 类成员之间使用空行隔开。 #  示例：\n// good class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { readonly state: ButtonState = { clicked: false }; render() { // ...  } } // bad class Button extends PureComponent\u0026lt;ButtonProps, ButtonState\u0026gt; { public state: ButtonState = { clicked: false }; constructor(props: ButtonProps) { super(props); } public render() { // ...  } } [建议] 构造函数初始化实例属性时，应尽量使用参数属性。 #  [建议] 构造函数的参数中，作为属性的参数应排列于其他参数前。 #  示例：\n// good class AppComponent { constructor(private readonly heroService: HeroService) {} } // bad class AppComponent { private readonly heroService: HeroService; constructor(heroService: HeroService) { this.heroService = heroService; } } 3.9 模块 #  [强制] 使用 ECMAScript 2015 标准的模块系统。 #  [强制] 除类型声明文件外，不使用 module / namespace 关键字。 #  [强制] 不使用 /// \u0026lt;reference path= \u0026gt; 。 #  示例：\n// good import foo from \u0026#34;foo\u0026#34;; // bad import foo = require(\u0026#34;foo\u0026#34;); [强制] 对于同一个模块路径，仅 import 一次。 #  示例：\n// good import React, { PureComponent } from \u0026#34;react\u0026#34;; // bad import React from \u0026#34;react\u0026#34;; import { PureComponent } from \u0026#34;react\u0026#34;; [建议] 对于使用 webpack 等构建工具的项目，在模块中引入其他资源（如样式、图片等）时，为资源编写类型声明文件，或使用合适的 loader 生成类型声明文件。 #  示例：\n// good  // Button.scss.d.ts export clicked: string; // logo.png.d.ts declare const logo: string; export default logo; // Button.tsx import styles from \u0026#39;./Button.scss\u0026#39;; import logo from \u0026#39;./logo.png\u0026#39;; // bad const styles = require\u0026lt;any\u0026gt;(\u0026#39;./Button.scss\u0026#39;); const logo = require\u0026lt;string\u0026gt;(\u0026#39;./logo.png\u0026#39;); "}),a.add({id:16,href:'/study-javascript/docs/basic/practice/spec/baidu/vue/',title:"Vue",section:"百度前端编程规范",content:"Vue 组件代码规范 #  1 前言\n2 代码风格\n2.1 缩进\n2.2 单行最长限制\n2.3 模块书写顺序\n3 template 部分\n3.1 根节点\n3.2 标签\n3.3 属性\n3.4 指令\n3.5 插值（Mustache）\n3.6 空格\n3.7 变量\n4 javascript 部分\n4.1 props\n4.2 data\n4.3 变量\n4.4 其他\n5 style 部分\n6 参考\n1 前言 #  任何问题或建议，欢迎跟我们讨论: fe-styleguide@baidu.com\n2 代码风格 #  2.1 缩进 #  [强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格或 tab 字符 #  2.2 单行最长限制 #  [强制] 每行不得超过 120 个字符 #  2.3 模块书写顺序 #  [建议] template -\u0026gt; script -\u0026gt; style #  3 template 部分 #  3.1 根节点 #  [强制] template 根节点只允许包含一个直接子节点，以下情况都是不允许的： #   根结点为空； 根结点是文字； 根结点有多个元素； 在根结点使用循环； 在根结点使用 template 和 slot； 在根结点使用 v-if，但是没有 v-else；  // bad \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt; \u0026lt;template \u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;two\u0026lt;/div\u0026gt;\u0026lt;/template \u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-for=\u0026#34;x in list\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;template\u0026gt;hello\u0026lt;/template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template\u0026gt;\u0026lt;div v-if=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt;\u0026lt;div\u0026gt;one\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt; 3.2 标签 #  [强制] 自定义组件的标签名不得使用 HTML 中默认已定义的标签（reserved HTML elements），要求至少由两个单词组成，并且符合 kebab-case #  解释：\n避免和 HTML 保留字段冲突导致错误。\n// bad \u0026lt;template\u0026gt; \u0026lt;sub /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { sub: OtherComponent } }; \u0026lt;/script\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;other-component /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import OtherComponent from \u0026#34;./OtherComponent.vue\u0026#34;; export default { components: { OtherComponent } }; \u0026lt;/script\u0026gt; // bad \u0026lt;component /\u0026gt; \u0026lt;mycomponent /\u0026gt; \u0026lt;myComponent /\u0026gt; \u0026lt;MyComponent /\u0026gt; // good \u0026lt;my-component /\u0026gt;  预留的 html 标签包括：\n  html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot；\n  预留的 SVG 标签包括：\n  svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view\n [强制]html void element 不需要闭合，其它类型标签都需要闭合 #  // bad \u0026lt;input\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;br\u0026gt;\u0026lt;/br\u0026gt; // good \u0026lt;input\u0026gt; \u0026lt;br\u0026gt; [强制] 非根结点的 template 标签里必须有一个以上的子结点 #  // bad \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;ul\u0026gt; \u0026lt;template\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; [强制] template 标签上不能带有 key 属性 #  // bad \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;template key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template v-bind:key=\u0026#34;y\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template :key=\u0026#34;z\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div key=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; [强制] 如果自定义标签中没有内容，需要以自闭合标签形式出现 #  // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/c-title\u0026gt; // good \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [强制] 标签右括号 \u0026gt; 的位置： #   元素只有一行时，右括号与元素保持在同一行。 多行元素（元素最后一个属性与左括号 \u0026lt; 不在同一行）时，右括号 \u0026gt; 需要另起一行，缩进与左括号 \u0026lt; 保持对齐。  // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // bad \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div id=\u0026#34;foo\u0026#34; class=\u0026#34;bar\u0026#34;\u0026gt; some message \u0026lt;/div\u0026gt; // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 自闭合标签的 /\u0026gt; 前不用添加空格 #  // bad \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;c-title :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; 3.3 属性 #  [强制] 属性值必须用双引号包围 #  // bad \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;c-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [强制] 模板中的属性命名需要符合 kebab-case #  // bad \u0026lt;my-component greetingText=\u0026#34;hi\u0026#34; /\u0026gt; // good \u0026lt;my-component greeting-text=\u0026#34;hi\u0026#34; /\u0026gt; [强制] class / style 属性值不能设置空字符串 #  // bad \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; [建议] 布尔类型的属性值为 true 时，建议不添加属性值 #  // bad \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;true\u0026#34; /\u0026gt; // good \u0026lt;input type=\u0026#34;text\u0026#34; disabled /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; arrow /\u0026gt; \u0026lt;c-title text=\u0026#34;带箭头标题\u0026#34; :arrow=\u0026#34;false\u0026#34; /\u0026gt; [强制] 当组件的属性多于 2 个时，必须分成多行，每行写一个属性；只有属性个数小于或等于 2 个时，可以写在一行内 #  // bad \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; // good \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; /\u0026gt; \u0026lt;c-title :text=\u0026#34;text\u0026#34; :url=\u0026#34;url\u0026#34; :label-type=\u0026#34;type\u0026#34; /\u0026gt; [建议] 当元素有多个属性时，应该按照统一的顺序书写 #  优先级顺序：\n 定义（提供组件的选项）  is   列表渲染（创建多个变化的相同元素）  v-for   条件渲染（元素是否渲染/显示）  v-if v-else-if v-else v-show v-cloak   渲染方式（改变元素的渲染方式）  v-pre/v-once   全局感知（需要超越组件的知识）  id   唯一的特性（需要唯一值的特性）  ref key slot   双向绑定（把绑定和事件结合起来）  v-model   未绑定的属性 其它绑定（所有普通的绑定）  v-bind   事件（组件事件监听器）  v-on   内容（覆写元素的内容）  v-html v-text    [强制] 不能有重复的属性，class 和 style 除外 #  解释：\n这里重复的属性包括以下两种情况：\n 属性名完全一样：如有多个 foo 或者有多个 :foo 有一个普通属性和一个 v-bind 动态绑定的属性，动态绑定的属性名与普通属性名重复  // bad \u0026lt;c-title foo=\u0026#34;abc\u0026#34; :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;def\u0026#34; foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;def\u0026#34; class=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;def\u0026#34; style=\u0026#34;abc\u0026#34; /\u0026gt; // good \u0026lt;c-title :foo=\u0026#34;def\u0026#34; /\u0026gt; \u0026lt;c-title foo=\u0026#34;abc\u0026#34; /\u0026gt; \u0026lt;c-title class=\u0026#34;c-color\u0026#34; :class=\u0026#34;{\u0026#39;c-selected\u0026#39;: selected}\u0026#34; /\u0026gt; \u0026lt;c-title style=\u0026#34;color: #000;\u0026#34; :style=\u0026#34;{width: \u0026#39;100px\u0026#39;}\u0026#34; /\u0026gt; [建议] slot 命名采用 kebab-case #  \u0026lt;slot name=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div slot=\u0026#34;header-left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; [建议] ref 命名采用 PascalCase #  \u0026lt;div ref=\u0026#34;userInfo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.4 指令 #  [强制] 在使用 v-for 的元素上添加 key，以便维护内部组件及其子树的状态 #  \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; [建议] 不要把 v-if 和 v-for 同时用在同一个元素上 #  解释：\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。所以如果想要使用 v-if 判断 v-for 元素列表是否显示，将两个指令同时应用在同一个元素的方法就是错误的。引入这个规则是为了避免引起困惑。\n// bad \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in users\u0026#34; v-if=\u0026#34;user.isActive\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; // good \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;user in activeUsers\u0026#34; :key=\u0026#34;user.id\u0026#34;\u0026gt; {{ user.name }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { activeUsers: function() { return this.users.filter(function(user) { return user.isActive; }); } } }; \u0026lt;/script\u0026gt; [建议] 以下指令统一使用缩写 #   使用 : 表示 v-bind: 使用 @ 表示 v-on:  3.5 插值（Mustache） #  [建议] 插值左右添加一个空格 #  // bad \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{text}}\u0026lt;/div\u0026gt; // good \u0026lt;div\u0026gt;{{ text }}\u0026lt;/div\u0026gt; 3.6 空格 #  [强制] 不能有多余空格 #  // bad \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // good \u0026lt;div class=\u0026#34;foo\u0026#34; :style=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 3.7 变量 #  [强制] 不能有多余的变量 #  // bad \u0026lt;ol\u0026gt; \u0026lt;!-- \u0026#34;i\u0026#34; is defined but never used. --\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; // good \u0026lt;ol\u0026gt; \u0026lt;li v-for=\u0026#34;i in 5\u0026#34;\u0026gt;{{ i }}\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; [强制] 禁止在插值中使用 this #  // bad \u0026lt;a :href=\u0026#34;this.url\u0026#34;\u0026gt; {{ this.text }} \u0026lt;/a\u0026gt; // good \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt; {{ text }} \u0026lt;/a\u0026gt; 4 javascript 部分 #  4.1 props #  [强制] 指定 props 类型 #  // bad \u0026lt;script\u0026gt; export default { props: [\u0026#39;status\u0026#39;] }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { status: String } }; [强制] 如果 props 没有指定为 required 或者 required 为 false，则需要指定默认值 #  // bad \u0026lt;script\u0026gt; export default { props: { a: Number, b: [Number, String], c: { type: Number }, d: { type: Number, required: false } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { a: { type: Number, required: true }, b: { type: [Number, String], default: 0 }, c: { type: Number, default: 0, required: false } } }; \u0026lt;/script\u0026gt; [强制] props 提供的默认值必须满足校验条件 #  // bad \u0026lt;script\u0026gt; export default { props: { propA: { type: String, default: {} }, propB: { type: String, default: [] }, propC: { type: Object, default: [] }, propD: { type: Array, default: [] }, propE: { type: Object, default: { message: \u0026#39;hello\u0026#39; } } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { propA: Number, propB: [String, Number], propD: { type: Number, default: 100 }, propE: { type: Object, default() { return { message: \u0026#39;hello\u0026#39; }; } } } }; [强制] 在 props 中声明的属性，其属性名应该始终符合 camelCase #  // bad \u0026lt;script\u0026gt; export default { props: { \u0026#34;greeting-text\u0026#34;: String } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { greetingText: String } }; \u0026lt;/script\u0026gt; 4.2 data #  [强制] data 必须是一个函数 #  // bad \u0026lt;script\u0026gt; export default { data: { b: 1 } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { data() { return { b: 1 }; } }; \u0026lt;/script\u0026gt; [强制] data 中禁止使用 computed 中的变量 #  // bad \u0026lt;script\u0026gt; export default { props: { a: { type: String, default: 0 } }, data() { return { d: this.f }; }, computed: { f() { return this.a * 10; } } }; \u0026lt;/script\u0026gt; [强制] props, data, computed, methods 中不能有重复的 key #  // bad \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { foo: null }; }, computed: { foo() { return \u0026#34;foo\u0026#34;; } } }; \u0026lt;/script\u0026gt; // good \u0026lt;script\u0026gt; export default { props: { foo: String }, data() { return { bar: null }; }, computed: { baz() { return foo + bar; } } }; \u0026lt;/script\u0026gt; 4.3 变量 #  [强制] 不能使用 Vue 中的保留字段命名变量 #  解释：\nVue 使用 _ 前缀来定义其自身的私有属性，所以使用相同的前缀 (比如 _update) 有覆写实例属性的风险。即便你检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。\n对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。\n不过，我们推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。\n// bad \u0026lt;script\u0026gt; export default { props: { $el: String }, data() { return { _foo: null }; }, computed: { $on() { return 2; } }, methods: { $nextTick() {} } }; \u0026lt;/script\u0026gt; 4.4 其它 #  [建议] 组件中使用 $emit 事件时携带的参数，个数不应该超过 2 个。建议将数据参数以 Object 形式传递，将事件参数 event 放在最后 #  // bad onClick(event) { this.$emit(\u0026#39;click\u0026#39;, this.value1, this.value2, event); } // good onClick(event) { this.$emit( \u0026#39;click\u0026#39;, { value1: this.value1, value2: this.value2 }, event ); } // good onClick(event) { this.$emit(\u0026#39;click\u0026#39;, event); } 5 style 部分 #  [建议] 为组件样式设置作用域 #  \u0026lt;style scoped\u0026gt; .button { border: none; border-radius: 2px; } \u0026lt;/style\u0026gt; 6 参考 #   vue 代码风格指南 ecomfe HTML 编码规范 ecomfe JavaScript 编码规范 ecomfe JavaScript 编码规范 - ESNext 补充篇（草案） ecomfe CSS 编码规范 ecomfe less 编码规范  "})})()